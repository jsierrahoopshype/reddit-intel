<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HoopsHype Reddit Intel</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
/* ===== RESET & BASE ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-tertiary: #e9ecef;
  --bg-card: #ffffff;
  --text-primary: #1a1a2e;
  --text-secondary: #6c757d;
  --text-muted: #adb5bd;
  --accent: #f97316;
  --accent-hover: #ea580c;
  --accent-dim: #fff7ed;
  --border: #dee2e6;
  --success: #16a34a;
  --danger: #dc2626;
  --warning: #ca8a04;
  --info: #2563eb;
  --radius: 8px;
  --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
}
html { font-size: 14px; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg-secondary);
  color: var(--text-primary);
  min-height: 100vh;
  line-height: 1.5;
}
a { color: #2563eb; text-decoration: none; }
a:hover { color: var(--accent); text-decoration: underline; }

/* ===== HEADER ===== */
.header {
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
  padding: 12px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  z-index: 100;
  box-shadow: var(--shadow);
}
.header-left { display: flex; align-items: center; gap: 12px; }
.logo { font-size: 1.4rem; font-weight: 700; color: #333; }
.logo-sub { font-size: 0.85rem; color: var(--text-secondary); }
.api-status {
  display: flex; align-items: center; gap: 6px;
  font-size: 0.8rem; color: var(--text-secondary);
  background: var(--bg-secondary); padding: 4px 10px;
  border-radius: 20px; border: 1px solid var(--border);
}
.api-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--text-muted);
}
.api-dot.online { background: var(--success); }
.api-dot.offline { background: var(--danger); }

/* ===== TAB NAV ===== */
.tab-nav {
  display: flex;
  background: var(--bg-primary);
  border-bottom: 2px solid var(--border);
  overflow-x: auto;
  scrollbar-width: thin;
}
.tab-btn {
  background: none; border: none; color: var(--text-secondary);
  padding: 12px 18px; cursor: pointer; white-space: nowrap;
  font-size: 0.85rem; font-weight: 500;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
  margin-bottom: -2px;
}
.tab-btn:hover { color: var(--text-primary); background: var(--bg-secondary); }
.tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

/* ===== MAIN CONTENT ===== */
.main { max-width: 1400px; margin: 0 auto; padding: 20px; }
.tab-panel { display: none; }
.tab-panel.active { display: block; }

/* ===== FORM CONTROLS ===== */
.controls {
  display: flex; flex-wrap: wrap; gap: 10px;
  align-items: flex-end;
  margin-bottom: 20px;
  padding: 16px;
  background: var(--bg-primary);
  border-radius: var(--radius);
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
}
.form-group { display: flex; flex-direction: column; gap: 4px; }
.form-group label {
  font-size: 0.75rem; color: var(--text-secondary);
  text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
}
input[type="text"], input[type="date"], input[type="number"], select {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 8px 12px;
  border-radius: var(--radius);
  font-size: 0.9rem;
  min-width: 160px;
}
input:focus, select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
.btn {
  background: var(--accent);
  color: #fff; border: none;
  padding: 8px 18px; border-radius: var(--radius);
  cursor: pointer; font-weight: 600; font-size: 0.85rem;
  transition: background 0.2s;
  white-space: nowrap;
}
.btn:hover { background: var(--accent-hover); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-sm { padding: 5px 12px; font-size: 0.8rem; }
.btn-secondary { background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--bg-tertiary); }
.btn-success { background: var(--success); }
.btn-info { background: var(--info); }

/* ===== TABLE ===== */
.table-wrap { overflow-x: auto; margin: 16px 0; }
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}
th {
  background: var(--bg-secondary);
  color: var(--text-secondary);
  text-transform: uppercase;
  font-size: 0.75rem;
  letter-spacing: 0.5px;
  text-align: left;
  padding: 10px 12px;
  white-space: nowrap;
  cursor: pointer;
  user-select: none;
  border-bottom: 2px solid var(--border);
}
th:hover { color: #333; font-weight: 700; }
th .sort-arrow { font-size: 0.65rem; margin-left: 3px; }
td {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
}
tr:hover { background: var(--bg-secondary); }

/* ===== CARDS ===== */
.card {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 16px;
  box-shadow: var(--shadow);
}
.card-title {
  font-size: 1rem; font-weight: 600;
  margin-bottom: 8px; color: #333;
}
.card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 16px;
}
.stat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
  margin-bottom: 20px;
}
.stat-card {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 14px;
  text-align: center;
  box-shadow: var(--shadow);
}
.stat-value { font-size: 1.8rem; font-weight: 700; color: #333; }
.stat-label { font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; margin-top: 4px; }

/* ===== CHART ===== */
.chart-container {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin: 16px 0;
  position: relative;
  box-shadow: var(--shadow);
}
.chart-container canvas { max-height: 350px; }

/* ===== LOADING & STATES ===== */
.spinner {
  display: inline-block;
  width: 20px; height: 20px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loading-overlay {
  display: flex; align-items: center; justify-content: center;
  gap: 10px; padding: 40px;
  color: var(--text-secondary);
}
.progress-bar {
  width: 100%; height: 6px;
  background: var(--bg-tertiary);
  border-radius: 3px;
  overflow: hidden;
  margin: 10px 0;
}
.progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 3px;
  transition: width 0.3s;
  width: 0%;
}
.empty-state {
  text-align: center; padding: 40px;
  color: var(--text-muted);
}
.error-msg {
  background: #fef2f2;
  color: var(--danger);
  border: 1px solid #fecaca;
  padding: 10px 16px;
  border-radius: var(--radius);
  margin: 10px 0;
  font-size: 0.85rem;
}
.toast {
  position: fixed; bottom: 20px; right: 20px;
  background: var(--bg-primary); color: var(--text-primary);
  padding: 10px 20px; border-radius: var(--radius);
  border: 1px solid var(--accent);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 1000; font-size: 0.85rem;
  animation: fadeInUp 0.3s;
}
@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ===== COMMENT CARD ===== */
.comment-card {
  background: var(--bg-secondary);
  border-left: 3px solid var(--accent);
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 0 var(--radius) var(--radius) 0;
}
.comment-meta {
  font-size: 0.75rem; color: var(--text-secondary);
  margin-top: 6px;
  display: flex; gap: 12px; flex-wrap: wrap;
  align-items: center;
}
.comment-body { white-space: pre-wrap; word-break: break-word; }
.comment-actions { display: flex; gap: 6px; margin-top: 8px; }

/* ===== BADGES ===== */
.badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
}
.badge-orange { background: var(--accent-dim); color: var(--accent); }
.badge-green { background: #dcfce7; color: var(--success); }
.badge-blue { background: #dbeafe; color: var(--info); }
.badge-red { background: #fef2f2; color: var(--danger); }

/* ===== WORD CLOUD ===== */
.word-cloud {
  display: flex; flex-wrap: wrap; gap: 6px;
  padding: 16px; justify-content: center;
}
.word-tag {
  background: var(--bg-secondary);
  padding: 4px 10px;
  border-radius: 14px;
  font-size: 0.8rem;
  border: 1px solid var(--border);
}

/* ===== TEAM SELECT GRID ===== */
.team-select-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 6px;
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
  background: var(--bg-secondary);
  border-radius: var(--radius);
  border: 1px solid var(--border);
}
.team-checkbox { display: flex; align-items: center; gap: 4px; font-size: 0.8rem; cursor: pointer; }
.team-checkbox input { accent-color: var(--accent); }

/* ===== EXPAND ===== */
.expandable { cursor: pointer; }
.expand-content { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border); }
.expand-content.open { display: block; }

/* ===== FOOTER ===== */
.footer {
  text-align: center; padding: 20px;
  color: var(--text-muted); font-size: 0.75rem;
  border-top: 1px solid var(--border);
  margin-top: 40px;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .header { flex-direction: column; gap: 8px; padding: 10px; }
  .tab-btn { padding: 10px 12px; font-size: 0.8rem; }
  .controls { flex-direction: column; }
  .form-group { width: 100%; }
  input[type="text"], input[type="date"], input[type="number"], select { width: 100%; min-width: unset; }
  .card-grid { grid-template-columns: 1fr; }
  .stat-grid { grid-template-columns: repeat(2, 1fr); }
  .main { padding: 10px; }
}

/* ===== MARKDOWN BRIEF ===== */
.markdown-brief {
  background: var(--bg-secondary);
  padding: 16px;
  border-radius: var(--radius);
  white-space: pre-wrap;
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  max-height: 500px;
  overflow-y: auto;
  border: 1px solid var(--border);
}
.compare-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
@media (max-width: 768px) {
  .compare-grid { grid-template-columns: 1fr; }
}

/* ===== THUMBNAILS ===== */
.thumb-img {
  width: 80px; height: 80px;
  object-fit: cover;
  border-radius: 4px;
  flex-shrink: 0;
}

/* ===== SCROLLABLE COMMENTS ===== */
.comment-scroll {
  max-height: 300px;
  overflow-y: auto;
}

/* ===== TREND CARDS ===== */
.trend-card {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}
.trend-card-body {
  flex: 1;
  min-width: 0;
}
.trend-card-title {
  font-weight: 600;
  margin-bottom: 4px;
}
.trend-card-title a { color: #333; }
.trend-card-title a:hover { color: var(--accent); }
.sort-controls {
  display: flex; gap: 6px; margin-bottom: 12px; flex-wrap: wrap;
}
.sort-controls .btn.active-sort {
  background: var(--accent); color: #fff;
}
.sub-tab-controls {
  display: flex; gap: 6px; margin-bottom: 16px;
}
.sub-tab-controls .btn.active-sort {
  background: var(--accent); color: #fff;
}
.sentiment-gauge {
  display: flex; flex-direction: column; align-items: center; justify-content: center;
}
.gauge-score {
  font-size: 3rem; font-weight: 700;
}
.gauge-bar {
  width: 80%; height: 12px;
  background: linear-gradient(to right, var(--danger), #e5e7eb 50%, var(--success));
  border-radius: 6px; position: relative; margin-top: 12px;
}
.gauge-marker {
  position: absolute; top: -4px; transform: translateX(-50%);
  width: 16px; height: 16px; background: #333; border-radius: 50%;
  border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,.3);
}
.clickable-comment { display: block; text-decoration: none; color: inherit; }
.clickable-comment:hover { text-decoration: none; }
.clickable-comment:hover .comment-card { background: #f0f1f3; }
#debugBanner {
  background: #fef3c7; border-bottom: 2px solid #f59e0b; padding: 8px 16px;
  font-family: monospace; font-size: 0.8rem; color: #92400e;
  display: flex; gap: 16px; flex-wrap: wrap; align-items: center;
}
#debugBanner strong { color: #78350f; }
</style>
</head>
<body>

<div id="debugBanner"><strong>DEBUG:</strong> <span id="debugUrl">No API calls yet</span> | <span id="debugCount">Results: —</span> | <span id="debugMaxScore">Max Score: —</span></div>

<!-- ===== HEADER ===== -->
<header class="header">
  <div class="header-left">
    <div>
      <div class="logo">HoopsHype Reddit Intel</div>
      <div class="logo-sub">NBA Reddit Intelligence Dashboard</div>
    </div>
  </div>
  <div class="api-status">
    <span class="api-dot" id="apiDot"></span>
    <span id="apiStatusText">Checking API...</span>
  </div>
</header>

<!-- ===== TAB NAV ===== -->
<nav class="tab-nav" id="tabNav">
  <button class="tab-btn" data-tab="rumors">Rumor & Buzz Tracker</button>
  <button class="tab-btn active" data-tab="trends">Trend Detection</button>
  <button class="tab-btn" data-tab="sentiment">Fan Sentiment</button>
  <button class="tab-btn" data-tab="perception">Player Perception</button>
  <button class="tab-btn" data-tab="social">Content Sourcing</button>
  <button class="tab-btn" data-tab="growth">Subreddit Growth</button>
  <button class="tab-btn" data-tab="history">Historical Reactions</button>
</nav>

<!-- ===== MAIN ===== -->
<main class="main">

<!-- TAB 1: RUMOR TRACKER -->
<div class="tab-panel" id="tab-rumors">
  <div class="controls">
    <div class="form-group">
      <label>Keyword / Player</label>
      <input type="text" id="rumorQuery" placeholder='e.g. "Jimmy Butler trade"'>
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="rumorAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="rumorBefore">
    </div>
    <button class="btn" onclick="searchRumors()">Search</button>
    <button class="btn btn-secondary" onclick="exportRumorCSV()">Export CSV</button>
  </div>
  <div id="rumorChart" class="chart-container" style="display:none"><canvas id="rumorChartCanvas"></canvas></div>
  <div id="rumorStats"></div>
  <div id="rumorTableWrap"><div class="empty-state">Enter a keyword and click Search to find NBA rumors and buzz.</div></div>
</div>

<!-- TAB 2: TREND DETECTION -->
<div class="tab-panel active" id="tab-trends">
  <div class="controls">
    <div class="form-group">
      <label>Time Period</label>
      <select id="trendPeriod">
        <option value="6">Last 6 Hours</option>
        <option value="24" selected>Last 24 Hours</option>
        <option value="168">Last 7 Days</option>
        <option value="720">Last 30 Days</option>
        <option value="2160">Last 90 Days</option>
      </select>
    </div>
    <button class="btn" onclick="currentTrendView==='posts'?loadTrends():loadTopComments()">Analyze</button>
  </div>
  <div class="sub-tab-controls">
    <button class="btn btn-sm active-sort" id="trendSubPosts" onclick="switchTrendView('posts')">Top Posts</button>
    <button class="btn btn-sm btn-secondary" id="trendSubComments" onclick="switchTrendView('comments')">Top Comments</button>
  </div>
  <div id="trendStats"></div>
  <div id="trendChart" class="chart-container" style="display:none"><canvas id="trendChartCanvas"></canvas></div>
  <div id="trendUnderserved" style="display:none"></div>
  <div id="trendResults"><div class="empty-state">Select a time period and click Analyze to detect trending topics on r/nba.</div></div>
</div>

<!-- TAB 3: FAN SENTIMENT -->
<div class="tab-panel" id="tab-sentiment">
  <div class="controls">
    <div class="form-group">
      <label>Team</label>
      <select id="sentimentTeam"></select>
    </div>
    <div class="form-group">
      <label>Compare With</label>
      <select id="sentimentTeam2"><option value="">-- None --</option></select>
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="sentimentAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="sentimentBefore">
    </div>
    <div class="form-group">
      <label>Precision</label>
      <select id="sentimentPrecision">
        <option value="day" selected>Daily</option>
        <option value="week">Weekly</option>
        <option value="month">Monthly</option>
      </select>
    </div>
    <button class="btn" onclick="loadSentiment()">Load Data</button>
  </div>
  <div id="sentimentCharts"></div>
  <div id="sentimentResults"><div class="empty-state">Select a team and date range to view fan activity trends.</div></div>
</div>

<!-- TAB 4: PLAYER PERCEPTION -->
<div class="tab-panel" id="tab-perception">
  <div class="controls">
    <div class="form-group">
      <label>Player Name</label>
      <input type="text" id="perceptionPlayer" placeholder="e.g. LeBron James">
    </div>
    <div class="form-group">
      <label>Date Range</label>
      <select id="perceptionRange">
        <option value="6">Last 6 Hours</option>
        <option value="24" selected>Last 24 Hours</option>
        <option value="168">Last 7 Days</option>
        <option value="720">Last 30 Days</option>
        <option value="2160">Last 90 Days</option>
      </select>
    </div>
    <button class="btn" onclick="analyzePerception()">Analyze</button>
  </div>
  <div class="form-group" style="margin-bottom:16px">
    <label>Select Team Subreddits (up to 5)</label>
    <div class="team-select-grid" id="perceptionTeams"></div>
  </div>
  <div id="perceptionResults"><div class="empty-state">Enter a player name and select subreddits to analyze perception across fanbases.</div></div>
</div>

<!-- TAB 5: SOCIAL CONTENT -->
<div class="tab-panel" id="tab-social">
  <div class="controls">
    <div class="form-group">
      <label>Keyword / Player</label>
      <input type="text" id="socialQuery" placeholder='e.g. "Wembanyama"'>
    </div>
    <div class="form-group">
      <label>Min Score</label>
      <input type="number" id="socialMinScore" value="100" min="1">
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="socialAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="socialBefore">
    </div>
    <button class="btn" onclick="findViralTakes()">Find Viral Takes</button>
    <button class="btn btn-secondary" onclick="batchExportSocial(10)">Export Top 10</button>
    <button class="btn btn-secondary" onclick="batchExportSocial(25)">Export Top 25</button>
    <button class="btn btn-secondary" onclick="batchExportSocial(50)">Export Top 50</button>
  </div>
  <div id="socialResults"><div class="empty-state">Search for viral takes to source content for social media.</div></div>
</div>

<!-- TAB 6: SUBREDDIT GROWTH -->
<div class="tab-panel" id="tab-growth">
  <div class="controls">
    <button class="btn" onclick="loadGrowthData()">Load All Team Data</button>
    <span class="form-group" style="flex:1">
      <div class="progress-bar" id="growthProgress" style="display:none"><div class="progress-fill" id="growthProgressFill"></div></div>
    </span>
  </div>
  <div id="growthChart" class="chart-container" style="display:none"><canvas id="growthChartCanvas"></canvas></div>
  <div id="growthResults"><div class="empty-state">Click "Load All Team Data" to fetch activity data for all 30 NBA team subreddits. This makes many API calls and may take a minute.</div></div>
</div>

<!-- TAB 7: HISTORICAL REACTIONS -->
<div class="tab-panel" id="tab-history">
  <div class="controls">
    <div class="form-group">
      <label>Search Query</label>
      <input type="text" id="historyQuery" placeholder='e.g. "Harden trade"'>
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="historyAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="historyBefore">
    </div>
    <button class="btn" onclick="searchHistory()">Search</button>
    <button class="btn btn-secondary" onclick="generateBrief()">Generate Article Brief</button>
  </div>
  <div id="historyResults"><div class="empty-state">Search for any NBA event to see how Reddit reacted. Try "Kawhi Clippers" or "2019 draft".</div></div>
  <div id="historyBrief" style="display:none"></div>
</div>

</main>

<!-- ===== FOOTER ===== -->
<footer class="footer">
  Built for HoopsHype editorial research. Data via <a href="https://arctic-shift.photon-reddit.com" target="_blank">Arctic Shift</a>.
</footer>

<script>
// =============================================================================
// CONFIGURATION
// =============================================================================
const API_BASE = 'https://arctic-shift.photon-reddit.com/api';
const CACHE_TTL = 3600000; // 1 hour
const RATE_LIMIT_MS = 500;

const NBA_TEAMS = {
  "Atlanta Hawks": "AtlantaHawks",
  "Boston Celtics": "bostonceltics",
  "Brooklyn Nets": "GoNets",
  "Charlotte Hornets": "CharlotteHornets",
  "Chicago Bulls": "chicagobulls",
  "Cleveland Cavaliers": "clevelandcavs",
  "Dallas Mavericks": "Mavericks",
  "Denver Nuggets": "denvernuggets",
  "Detroit Pistons": "DetroitPistons",
  "Golden State Warriors": "warriors",
  "Houston Rockets": "rockets",
  "Indiana Pacers": "pacers",
  "LA Clippers": "LAClippers",
  "Los Angeles Lakers": "lakers",
  "Memphis Grizzlies": "memphisgrizzlies",
  "Miami Heat": "heat",
  "Milwaukee Bucks": "MkeBucks",
  "Minnesota Timberwolves": "timberwolves",
  "New Orleans Pelicans": "NOLAPelicans",
  "New York Knicks": "NYKnicks",
  "Oklahoma City Thunder": "Thunder",
  "Orlando Magic": "OrlandoMagic",
  "Philadelphia 76ers": "sixers",
  "Phoenix Suns": "suns",
  "Portland Trail Blazers": "ripcity",
  "Sacramento Kings": "kings",
  "San Antonio Spurs": "NBASpurs",
  "Toronto Raptors": "torontoraptors",
  "Utah Jazz": "UtahJazz",
  "Washington Wizards": "washingtonwizards"
};

const SUB_TO_TEAM = {};
Object.entries(NBA_TEAMS).forEach(([team, sub]) => { SUB_TO_TEAM[sub.toLowerCase()] = team; });

const TOPIC_KEYWORDS = {
  trade: ['trade','traded','trading','deal','swap','package','assets'],
  GOAT: ['goat','greatest','all-time','all time','legacy','mount rushmore'],
  draft: ['draft','pick','prospect','lottery','combine','mock draft'],
  'free agency': ['free agent','free agency','signing','sign','unrestricted','restricted'],
  rookie: ['rookie','roty','first year','debut'],
  MVP: ['mvp','most valuable','award','frontrunner'],
  injury: ['injury','injured','acl','torn','surgery','rehab','out for','sidelined','day-to-day'],
  contract: ['contract','extension','max','supermax','salary','cap space','money']
};

const NBA_EVENTS = [
  { date: '2026-02-05', label: 'Trade Deadline' },
  { date: '2026-06-25', label: 'NBA Draft' },
  { date: '2026-06-30', label: 'Free Agency' },
  { date: '2025-10-22', label: 'Season Start' },
  { date: '2026-04-13', label: 'Playoffs Start' }
];

const STOPWORDS = new Set(['the','a','an','is','are','was','were','be','been','being','have','has','had',
  'do','does','did','will','would','could','should','may','might','shall','can','need','must',
  'to','of','in','for','on','with','at','by','from','as','into','through','during','before',
  'after','above','below','between','out','off','over','under','again','further','then','once',
  'here','there','when','where','why','how','all','both','each','few','more','most','other',
  'some','such','no','nor','not','only','own','same','so','than','too','very','just','about',
  'up','down','and','but','or','if','it','its','he','she','they','them','his','her','their',
  'this','that','these','those','i','me','my','we','us','our','you','your','what','which','who',
  'whom','get','got','like','really','think','know','make','go','going','even','still','also',
  'much','many','well','way','back','good','new','first','last','long','great','little','right',
  'old','big','high','different','small','large','next','one','two','dont','doesnt','didnt',
  'thats','hes','shes','theyre','youre','im','wont','cant','because','been','said','game',
  'player','team','season','year','nba','play','time','point','guy','people']);

// =============================================================================
// SENTIMENT ANALYSIS CONSTANTS
// =============================================================================
const POSITIVE_WORDS = new Set(['goat','amazing','incredible','beast','elite','love','great','best','mvp',
  'dominant','clutch','unstoppable','underrated','gem','special','generational','insane','fire','w','dub',
  'respect','legend','carry','star','skilled','smart','crafty','versatile','efficient','consistent',
  'reliable','automatic','lethal','polished','creative','cerebral','unguardable','lockdown','dpoy',
  'superstar','franchise','historic','cornerstone','untouchable','bargain','steal','max-worthy']);
const NEGATIVE_WORDS = new Set(['bust','overrated','trash','terrible','worst','hate','sucks','washed',
  'mid','l','fraud','overpaid','choker','liability','soft','disappointing','flop','garbage','bum','ass',
  'awful','horrible','mediocre','turnover','inconsistent','passive','lazy','careless','turnover-prone',
  'one-dimensional','predictable','injury-prone','streaky','invisible','disengaged','expendable','tradeable']);

const ADJECTIVE_MAP = {};
const ADJ_CATEGORIES = {
  physical: { words: ['tall','long','fast','slow','strong','athletic','big','quick','agile','physical','lanky','massive','explosive','mobile'], sentiment: 'neutral' },
  skill: { words: ['skilled','smart','crafty','versatile','efficient','consistent','reliable','automatic','lethal','polished','raw','creative','cerebral'], sentiment: 'positive' },
  performance: { words: ['dominant','elite','clutch','unstoppable','unguardable','lockdown','dpoy','superstar','franchise','generational','historic','mvp-level','all-star','all-nba'], sentiment: 'positive' },
  negPerformance: { words: ['inconsistent','passive','lazy','careless','turnover-prone','one-dimensional','predictable','injury-prone','streaky','invisible','disengaged'], sentiment: 'negative' },
  value: { words: ['overpaid','underpaid','untouchable','tradeable','expendable','cornerstone','max-worthy','bargain','steal'], sentiment: 'mixed' }
};
Object.entries(ADJ_CATEGORIES).forEach(([cat, {words, sentiment}]) => {
  words.forEach(w => {
    let s = sentiment;
    if (sentiment === 'mixed') s = ['overpaid','expendable','tradeable'].includes(w) ? 'negative' : 'positive';
    ADJECTIVE_MAP[w] = { category: cat, sentiment: s };
  });
});

const PLAYER_NICKNAMES = {
  'lebron james':['lebron','bron','lbj'], 'victor wembanyama':['wemby','wembanyama'],
  'anthony edwards':['ant','ant-man'], 'devin booker':['book','booker'],
  'luka doncic':['luka','doncic'], 'jayson tatum':['tatum','jt'],
  'giannis antetokounmpo':['giannis','greek freak'], 'nikola jokic':['jokic','joker'],
  'stephen curry':['steph','curry'], 'kevin durant':['kd','durant'],
  'joel embiid':['embiid','jojo'], 'jimmy butler':['jimmy','butler','jimmy buckets'],
  'damian lillard':['dame','lillard'], 'ja morant':['ja','morant'],
  'shai gilgeous-alexander':['sga','shai'], 'paolo banchero':['paolo','banchero'],
  'chet holmgren':['chet','holmgren'], 'scottie barnes':['scottie','barnes'],
  'tyrese haliburton':['haliburton'], 'donovan mitchell':['spida','mitchell'],
  'zion williamson':['zion']
};

function classifySentiment(text) {
  const words = text.toLowerCase().replace(/[^a-z0-9\s'-]/g,'').split(/\s+/);
  let pos = 0, neg = 0;
  words.forEach(w => { if (POSITIVE_WORDS.has(w)) pos++; if (NEGATIVE_WORDS.has(w)) neg++; });
  if (pos > neg) return { sentiment: 'positive', posCount: pos, negCount: neg };
  if (neg > pos) return { sentiment: 'negative', posCount: pos, negCount: neg };
  return { sentiment: 'neutral', posCount: pos, negCount: neg };
}

function extractAdjectives(text, playerTokens) {
  const words = text.toLowerCase().replace(/[^a-z0-9\s'-]/g,'').split(/\s+/);
  const found = [];
  const mentions = [];
  for (let i = 0; i < words.length; i++) {
    if (playerTokens.some(pt => words[i].includes(pt))) mentions.push(i);
  }
  if (mentions.length === 0) {
    words.forEach(w => { if (ADJECTIVE_MAP[w]) found.push(w); });
  } else {
    mentions.forEach(pos => {
      for (let j = Math.max(0, pos - 10); j < Math.min(words.length, pos + 11); j++) {
        if (ADJECTIVE_MAP[words[j]]) found.push(words[j]);
      }
    });
  }
  return found;
}

function extractComparisons(text) {
  const results = [];
  const patterns = [
    /(?:the\s+)?next\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)?)/g,
    /reminds?\s+(?:me\s+)?of\s+([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)?)/g,
    /(?:like|similar\s+to)\s+(?:a\s+)?(?:young\s+)?([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)?)/g
  ];
  const skip = new Set(['The','This','That','These','Those','What','When','Where','There','They','Some','His','Her']);
  patterns.forEach(re => { let m; while ((m = re.exec(text)) !== null) { if (!skip.has(m[1].split(' ')[0])) results.push(m[1].trim()); } });
  return results;
}

// =============================================================================
// UTILITIES: Rate Limiter
// =============================================================================
const RateLimiter = (() => {
  let lastCall = 0;
  return async () => {
    const now = Date.now();
    const wait = RATE_LIMIT_MS - (now - lastCall);
    if (wait > 0) await new Promise(r => setTimeout(r, wait));
    lastCall = Date.now();
  };
})();

// =============================================================================
// UTILITIES: Cache
// =============================================================================
const Cache = {
  get(key) {
    try {
      const item = localStorage.getItem('rhi_' + key);
      if (!item) return null;
      const { data, ts } = JSON.parse(item);
      if (Date.now() - ts > CACHE_TTL) { localStorage.removeItem('rhi_' + key); return null; }
      return data;
    } catch { return null; }
  },
  set(key, data) {
    try {
      localStorage.setItem('rhi_' + key, JSON.stringify({ data, ts: Date.now() }));
    } catch { /* storage full */ }
  }
};

// =============================================================================
// UTILITIES: API Client (with console debug logging)
// =============================================================================
async function api(endpoint, params = {}) {
  const filtered = {};
  Object.entries(params).forEach(([k, v]) => {
    if (v !== undefined && v !== null && v !== '') filtered[k] = v;
  });
  const qs = new URLSearchParams(filtered).toString();
  const url = `${API_BASE}${endpoint}${qs ? '?' + qs : ''}`;

  // Debug: log every API call to console AND debug banner
  console.log('[API]', url);
  const dbUrl = document.getElementById('debugUrl');
  if (dbUrl) dbUrl.textContent = url.replace(API_BASE, '');

  const cached = Cache.get(url);
  if (cached) {
    console.log('[API] Cache hit');
    updateDebugBanner(cached);
    return cached;
  }

  await RateLimiter();
  const res = await fetch(url);
  if (!res.ok) {
    const body = await res.text().catch(() => '');
    console.error('[API] Error', res.status, body);
    throw new Error(`API error ${res.status}: ${body || res.statusText}`);
  }
  const json = await res.json();
  if (json.error) {
    console.error('[API] Response error:', json.error);
    throw new Error(`API: ${json.error}`);
  }
  Cache.set(url, json);
  updateDebugBanner(json);
  return json;
}

function updateDebugBanner(json) {
  const dbCount = document.getElementById('debugCount');
  const dbMax = document.getElementById('debugMaxScore');
  if (!dbCount || !dbMax) return;
  const data = json.data || [];
  dbCount.textContent = `Results: ${data.length}`;
  if (data.length > 0) {
    const scores = data.map(d => d.score || 0);
    const maxScore = Math.max(...scores);
    dbMax.textContent = `Max Score: ${maxScore.toLocaleString()}`;
  }
}

// =============================================================================
// UTILITIES: Helpers
// =============================================================================
function formatDate(epoch) {
  if (!epoch) return '';
  const d = new Date(typeof epoch === 'number' ? epoch * 1000 : epoch);
  return d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
}

function formatDateISO(epoch) {
  const d = new Date(typeof epoch === 'number' ? epoch * 1000 : epoch);
  return d.toISOString().split('T')[0];
}

function daysAgo(n) {
  const d = new Date();
  d.setDate(d.getDate() - n);
  return d.toISOString().split('T')[0];
}

function hoursAgo(h) {
  return Math.floor((Date.now() - h * 3600000) / 1000);
}

async function apiWithRetry(endpoint, params = {}, maxRetries = 2) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await api(endpoint, params);
    } catch (e) {
      if (attempt < maxRetries) {
        const delay = 1000 * Math.pow(2, attempt);
        console.log(`[API] Retry ${attempt + 1}/${maxRetries} in ${delay}ms...`);
        await new Promise(r => setTimeout(r, delay));
      } else throw e;
    }
  }
}

function truncate(str, len) {
  if (!str) return '';
  return str.length > len ? str.substring(0, len) + '...' : str;
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function renderThumbnail(post) {
  const t = post.thumbnail || '';
  if (t && !['self','default','nsfw','spoiler',''].includes(t) && t.startsWith('http')) {
    return `<img src="${escapeHtml(t)}" class="thumb-img" onerror="this.style.display='none'" alt="">`;
  }
  const url = (post.url || '');
  if (/\.(jpg|jpeg|png|gif|webp)(\?|$)/i.test(url)) {
    return `<img src="${escapeHtml(url)}" class="thumb-img" onerror="this.style.display='none'" alt="">`;
  }
  if (/i\.redd\.it|i\.reddit\.com|i\.imgur\.com/i.test(url)) {
    return `<img src="${escapeHtml(url)}" class="thumb-img" onerror="this.style.display='none'" alt="">`;
  }
  const ytMatch = url.match(/(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
  if (ytMatch) return `<img src="https://img.youtube.com/vi/${ytMatch[1]}/mqdefault.jpg" class="thumb-img" onerror="this.style.display='none'" alt="">`;
  if (/v\.redd\.it/i.test(url)) {
    if (t && t.startsWith('http')) return `<div style="position:relative;display:inline-block"><img src="${escapeHtml(t)}" class="thumb-img" alt=""><div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.5rem;text-shadow:0 1px 3px rgba(0,0,0,.5)">&#9654;</div></div>`;
    return '<span class="badge badge-red" style="padding:4px 8px">Video</span>';
  }
  if (/streamable\.com/i.test(url)) return '<span class="badge badge-blue" style="padding:4px 8px">Video</span>';
  if (/twitter\.com|x\.com/i.test(url)) return '<span class="badge badge-blue" style="padding:4px 8px">Tweet</span>';
  return '';
}

function postPermalink(post) {
  return `https://www.reddit.com/r/${post.subreddit}/comments/${(post.id || '').replace('t3_','')}/`;
}

function commentPermalink(comment) {
  const linkId = (comment.link_id || '').replace('t3_', '');
  const commentId = (comment.id || '').replace('t1_', '');
  return `https://www.reddit.com/r/${comment.subreddit}/comments/${linkId}/_/${commentId}/`;
}

function showLoading(el) {
  el.innerHTML = '<div class="loading-overlay"><div class="spinner"></div> Loading...</div>';
}

function showError(el, msg) {
  el.innerHTML = `<div class="error-msg">${escapeHtml(msg)}</div>`;
}

function showEmpty(el, msg) {
  el.innerHTML = `<div class="empty-state">${escapeHtml(msg)}</div>`;
}

function toast(msg) {
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 2500);
}

async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    toast('Copied to clipboard!');
  } catch {
    toast('Copy failed — try manually.');
  }
}

function downloadFile(content, filename, type = 'text/csv') {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

// Chart.js defaults for light theme
Chart.defaults.color = '#6c757d';
Chart.defaults.borderColor = '#dee2e6';
Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif';

const charts = {};
function getOrCreateChart(canvasId, config) {
  if (charts[canvasId]) { charts[canvasId].destroy(); }
  const ctx = document.getElementById(canvasId).getContext('2d');
  charts[canvasId] = new Chart(ctx, config);
  return charts[canvasId];
}

const CHART_COLORS = ['#f97316','#2563eb','#16a34a','#ca8a04','#dc2626','#7c3aed','#db2777','#0891b2'];

// =============================================================================
// GENERIC SORTABLE TABLE
// =============================================================================
function renderSortableTable(containerId, data, columns, state) {
  if (!state._sort) { state._sort = columns.find(c => c.defaultSort)?.field || columns[0].field; state._asc = false; }
  const sorted = [...data].sort((a, b) => {
    let va = a[state._sort], vb = b[state._sort];
    if (va == null) va = typeof vb === 'number' ? 0 : '';
    if (vb == null) vb = typeof va === 'number' ? 0 : '';
    if (typeof va === 'string') { va = va.toLowerCase(); vb = (vb+'').toLowerCase(); }
    if (va < vb) return state._asc ? -1 : 1;
    if (va > vb) return state._asc ? 1 : -1;
    return 0;
  });

  const el = document.getElementById(containerId);
  el.innerHTML = `<div class="table-wrap"><table>
    <thead><tr>${columns.map(col => {
      const arrow = state._sort === col.field ? (state._asc ? ' <span class="sort-arrow">▲</span>' : ' <span class="sort-arrow">▼</span>') : '';
      return `<th data-sort="${col.field}">${col.label}${arrow}</th>`;
    }).join('')}</tr></thead>
    <tbody>${sorted.map(row => `<tr>${columns.map(col =>
      `<td>${col.render ? col.render(row) : escapeHtml(String(row[col.field] ?? ''))}</td>`
    ).join('')}</tr>`).join('')}</tbody>
  </table></div>`;

  el.querySelectorAll('th[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
      const f = th.dataset.sort;
      if (state._sort === f) state._asc = !state._asc;
      else { state._sort = f; state._asc = false; }
      renderSortableTable(containerId, data, columns, state);
    });
  });
}

// =============================================================================
// TAB NAVIGATION
// =============================================================================
function showTab(tabId) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tabId));
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.toggle('active', p.id === 'tab-' + tabId));
}

document.getElementById('tabNav').addEventListener('click', e => {
  if (e.target.classList.contains('tab-btn')) showTab(e.target.dataset.tab);
});

// =============================================================================
// TAB 1: RUMOR & BUZZ TRACKER
// =============================================================================
let rumorData = [];
const rumorSortState = {};
const RUMOR_SUBS = ['nba', 'nbadiscussion', 'NBA_TradeDiscussions'];

const RUMOR_COLUMNS = [
  { field: 'thumbnail', label: 'Media', render: p => renderThumbnail(p) },
  { field: 'title', label: 'Title', render: p => `<a href="${postPermalink(p)}" target="_blank">${escapeHtml(p.title)}</a>` },
  { field: 'subreddit', label: 'Subreddit', render: p => `<span class="badge badge-orange">r/${escapeHtml(p.subreddit)}</span>` },
  { field: 'score', label: 'Score', defaultSort: true, render: p => (p.score||0).toLocaleString() },
  { field: 'num_comments', label: 'Comments', render: p => (p.num_comments||0).toLocaleString() },
  { field: 'created_utc', label: 'Date', render: p => formatDate(p.created_utc) }
];

async function searchRumors() {
  const query = document.getElementById('rumorQuery').value.trim();
  if (!query) { toast('Please enter a search keyword.'); return; }
  const after = document.getElementById('rumorAfter').value;
  const before = document.getElementById('rumorBefore').value;
  const statsEl = document.getElementById('rumorStats');
  const tableEl = document.getElementById('rumorTableWrap');
  showLoading(tableEl);

  try {
    const allPosts = [];
    for (const sub of RUMOR_SUBS) {
      const res = await api('/posts/search', {
        subreddit: sub, query, after, before, limit: 'auto'
      });
      if (res.data) allPosts.push(...res.data);
    }
    rumorData = allPosts;

    if (!rumorData.length) { showEmpty(tableEl, 'No results found.'); statsEl.innerHTML = ''; return; }

    statsEl.innerHTML = `<div class="stat-grid">
      <div class="stat-card"><div class="stat-value">${rumorData.length}</div><div class="stat-label">Posts Found</div></div>
      <div class="stat-card"><div class="stat-value">${rumorData.reduce((s,p) => s + (p.score||0), 0).toLocaleString()}</div><div class="stat-label">Total Score</div></div>
      <div class="stat-card"><div class="stat-value">${rumorData.reduce((s,p) => s + (p.num_comments||0), 0).toLocaleString()}</div><div class="stat-label">Total Comments</div></div>
    </div>`;

    rumorSortState._sort = null; // reset
    renderSortableTable('rumorTableWrap', rumorData, RUMOR_COLUMNS, rumorSortState);

    // Time series chart
    try {
      const aggRes = await api('/posts/search/aggregate', {
        subreddit: 'nba', query, aggregate: 'created_utc',
        frequency: 'day', after, before
      });
      if (aggRes.data && aggRes.data.length > 0) {
        document.getElementById('rumorChart').style.display = 'block';
        const labels = aggRes.data.map(d => formatDate(d.created_utc));
        const values = aggRes.data.map(d => parseInt(d.count));
        getOrCreateChart('rumorChartCanvas', {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label: `"${query}" mentions/day on r/nba`,
              data: values,
              borderColor: '#f97316',
              backgroundColor: '#f9731633',
              fill: true, tension: 0.3, pointRadius: 2
            }]
          },
          options: { responsive: true, plugins: { legend: { display: true } }, scales: { y: { beginAtZero: true } } }
        });
      }
    } catch (e) { console.warn('Chart aggregate failed:', e); }
  } catch (err) {
    showError(tableEl, 'Error fetching rumors: ' + err.message);
  }
}

function exportRumorCSV() {
  if (!rumorData.length) { toast('No data to export.'); return; }
  const header = 'Title,Subreddit,Score,Comments,Date,URL\n';
  const rows = rumorData.map(p =>
    `"${(p.title||'').replace(/"/g,'""')}",r/${p.subreddit},${p.score||0},${p.num_comments||0},${formatDateISO(p.created_utc)},${postPermalink(p)}`
  ).join('\n');
  downloadFile(header + rows, 'rumor_results.csv');
  toast('CSV exported!');
}

// =============================================================================
// TAB 2: TREND DETECTION & CONTENT IDEAS
// =============================================================================
let trendData = [];
let trendTopics = {};
let trendCardSort = { field: 'score', asc: false };
let currentTrendView = 'posts';

function switchTrendView(view) {
  currentTrendView = view;
  document.getElementById('trendSubPosts').className = view === 'posts' ? 'btn btn-sm active-sort' : 'btn btn-sm btn-secondary';
  document.getElementById('trendSubComments').className = view === 'comments' ? 'btn btn-sm active-sort' : 'btn btn-sm btn-secondary';
  if (view === 'posts') loadTrends(); else loadTopComments();
}

async function loadTopComments() {
  const hours = parseInt(document.getElementById('trendPeriod').value);
  const after = hoursAgo(hours);
  const resultsEl = document.getElementById('trendResults');
  showLoading(resultsEl);
  document.getElementById('trendStats').innerHTML = '';
  document.getElementById('trendChart').style.display = 'none';
  document.getElementById('trendUnderserved').style.display = 'none';

  try {
    const subs = ['nba','nbadiscussion','NBA_TradeDiscussions'];
    let allComments = [];
    for (const sub of subs) {
      try {
        const res = await apiWithRetry('/comments/search', { subreddit: sub, after, limit: 'auto' });
        if (res.data) allComments.push(...res.data);
      } catch (e) { console.warn(`Top comments failed for r/${sub}:`, e.message); }
    }
    allComments.sort((a, b) => (b.score || 0) - (a.score || 0));
    const top50 = allComments.slice(0, 50);

    if (!top50.length) { showEmpty(resultsEl, 'No comments found for this time period.'); return; }

    document.getElementById('trendStats').innerHTML = `<div class="stat-grid">
      <div class="stat-card"><div class="stat-value">${allComments.length}</div><div class="stat-label">Comments Fetched</div></div>
      <div class="stat-card"><div class="stat-value">${(top50[0]?.score||0).toLocaleString()}</div><div class="stat-label">Highest Score</div></div>
      <div class="stat-card"><div class="stat-value">${Math.round(top50.reduce((s,c) => s + (c.score||0), 0) / top50.length).toLocaleString()}</div><div class="stat-label">Avg Score (Top 50)</div></div>
    </div>`;

    resultsEl.innerHTML = top50.map((c, i) => {
      const linkId = (c.link_id || '').replace('t3_', '');
      const threadUrl = `https://www.reddit.com/r/${c.subreddit}/comments/${linkId}/`;
      const cUrl = commentPermalink(c);
      return `<div class="card">
        <div style="color:var(--text-muted);font-size:0.8rem;margin-bottom:6px">#${i+1} &middot; Thread: <a href="${threadUrl}" target="_blank">${escapeHtml(c.link_title || 'View thread')}</a></div>
        <a href="${cUrl}" target="_blank" class="clickable-comment">
          <div class="comment-body comment-scroll" style="color:#333">${escapeHtml(c.body || '')}</div>
        </a>
        <div class="comment-meta">
          <span>u/${escapeHtml(c.author || '[deleted]')}</span>
          <span>Score: ${(c.score||0).toLocaleString()}</span>
          <span class="badge badge-orange">r/${escapeHtml(c.subreddit)}</span>
          <span>${formatDate(c.created_utc)}</span>
          <a href="${cUrl}" target="_blank">Permalink</a>
        </div>
      </div>`;
    }).join('');
  } catch (err) {
    showError(resultsEl, 'Error loading top comments: ' + err.message);
  }
}

async function loadTrends() {
  const hours = parseInt(document.getElementById('trendPeriod').value);
  const resultsEl = document.getElementById('trendResults');
  showLoading(resultsEl);

  try {
    const after = hoursAgo(hours);
    const res = await apiWithRetry('/posts/search', {
      subreddit: 'nba', after, limit: 'auto'
    });
    trendData = (res.data || []).sort((a, b) => (b.score || 0) - (a.score || 0));

    // Categorize posts into topics
    trendTopics = {};
    Object.keys(TOPIC_KEYWORDS).forEach(t => { trendTopics[t] = { posts: [], totalScore: 0, totalComments: 0 }; });
    trendTopics['other'] = { posts: [], totalScore: 0, totalComments: 0 };

    trendData.forEach(post => {
      const titleLower = (post.title || '').toLowerCase();
      let matched = false;
      Object.entries(TOPIC_KEYWORDS).forEach(([topic, keywords]) => {
        if (keywords.some(kw => titleLower.includes(kw))) {
          trendTopics[topic].posts.push(post);
          trendTopics[topic].totalScore += (post.score || 0);
          trendTopics[topic].totalComments += (post.num_comments || 0);
          matched = true;
        }
      });
      if (!matched) {
        trendTopics['other'].posts.push(post);
        trendTopics['other'].totalScore += (post.score || 0);
        trendTopics['other'].totalComments += (post.num_comments || 0);
      }
    });

    // Stats
    document.getElementById('trendStats').innerHTML = `
      <div class="stat-grid">
        <div class="stat-card"><div class="stat-value">${trendData.length}</div><div class="stat-label">Posts Analyzed</div></div>
        <div class="stat-card"><div class="stat-value">${Object.keys(trendTopics).filter(t => trendTopics[t].posts.length > 0).length}</div><div class="stat-label">Topics Detected</div></div>
        <div class="stat-card"><div class="stat-value">${trendData.length > 0 ? Math.round(trendData.reduce((s,p) => s + (p.score||0), 0) / trendData.length).toLocaleString() : 0}</div><div class="stat-label">Avg Score</div></div>
      </div>`;

    // Bar chart
    const topicNames = Object.keys(trendTopics).filter(t => t !== 'other' && trendTopics[t].posts.length > 0);
    const engagement = topicNames.map(t => trendTopics[t].totalScore + trendTopics[t].totalComments);
    document.getElementById('trendChart').style.display = 'block';
    getOrCreateChart('trendChartCanvas', {
      type: 'bar',
      data: {
        labels: topicNames.map(t => t.charAt(0).toUpperCase() + t.slice(1)),
        datasets: [{
          label: 'Total Engagement (Score + Comments)',
          data: engagement,
          backgroundColor: CHART_COLORS.slice(0, topicNames.length)
        }]
      },
      options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } }
    });

    // Underserved topics
    const underserved = topicNames
      .filter(t => trendTopics[t].posts.length > 0)
      .map(t => ({ topic: t, count: trendTopics[t].posts.length, avgScore: Math.round(trendTopics[t].totalScore / trendTopics[t].posts.length), totalEngagement: trendTopics[t].totalScore + trendTopics[t].totalComments }))
      .sort((a, b) => b.avgScore - a.avgScore);
    const avgAvgScore = underserved.reduce((s, u) => s + u.avgScore, 0) / (underserved.length || 1);
    const highPerformers = underserved.filter(u => u.avgScore > avgAvgScore && u.count < trendData.length / Object.keys(trendTopics).length);
    const underEl = document.getElementById('trendUnderserved');
    if (highPerformers.length > 0) {
      underEl.style.display = 'block';
      underEl.innerHTML = `<div class="card"><div class="card-title">Underserved Topics (High Avg Score, Low Post Count)</div>
        <div class="table-wrap"><table><thead><tr><th>Topic</th><th>Post Count</th><th>Avg Score</th><th>Total Engagement</th></tr></thead>
        <tbody>${highPerformers.map(u => `<tr><td><span class="badge badge-green">${u.topic}</span></td><td>${u.count}</td><td>${u.avgScore.toLocaleString()}</td><td>${u.totalEngagement.toLocaleString()}</td></tr>`).join('')}</tbody></table></div></div>`;
    } else { underEl.style.display = 'none'; }

    // Unified "All Trending Content"
    resultsEl.innerHTML = `
      <h3 style="margin:20px 0 12px;color:#333;font-size:1.1rem">All Trending Content</h3>
      <div class="sort-controls">
        <button class="btn btn-sm active-sort" data-sort="score" onclick="sortTrendCards('score')">Score</button>
        <button class="btn btn-sm btn-secondary" data-sort="num_comments" onclick="sortTrendCards('num_comments')">Comments</button>
        <button class="btn btn-sm btn-secondary" data-sort="created_utc" onclick="sortTrendCards('created_utc')">Date</button>
      </div>
      <div id="trendCards"></div>`;
    trendCardSort = { field: 'score', asc: false };
    renderTrendCards();

  } catch (err) {
    showError(resultsEl, 'Error loading trends: ' + err.message);
  }
}

function sortTrendCards(field) {
  if (trendCardSort.field === field) {
    trendCardSort.asc = !trendCardSort.asc;
  } else {
    trendCardSort.field = field;
    trendCardSort.asc = false;
  }
  // Update button styles
  document.querySelectorAll('.sort-controls .btn').forEach(btn => {
    const isActive = btn.dataset.sort === field;
    btn.className = isActive ? 'btn btn-sm active-sort' : 'btn btn-sm btn-secondary';
  });
  renderTrendCards();
}

function renderTrendCards() {
  const sorted = [...trendData].sort((a, b) => {
    const va = a[trendCardSort.field] || 0, vb = b[trendCardSort.field] || 0;
    return trendCardSort.asc ? va - vb : vb - va;
  });
  const cardsEl = document.getElementById('trendCards');
  if (!cardsEl) return;
  cardsEl.innerHTML = sorted.slice(0, 50).map(p => {
    const pid = (p.id || '').replace('t3_', '');
    const thumb = renderThumbnail(p);
    return `<div class="card trend-card">
      ${thumb ? `<div>${thumb}</div>` : ''}
      <div class="trend-card-body">
        <div class="trend-card-title"><a href="${postPermalink(p)}" target="_blank">${escapeHtml(p.title)}</a></div>
        <div class="comment-meta">
          <span>Score: ${(p.score||0).toLocaleString()}</span>
          <span>${(p.num_comments||0).toLocaleString()} comments</span>
          <span>${formatDate(p.created_utc)}</span>
          <span>u/${escapeHtml(p.author || '[deleted]')}</span>
        </div>
        <button class="btn btn-sm btn-secondary" style="margin-top:8px" onclick="loadPostComments('${pid}', this)">Load Top & Bottom Comments</button>
        <div id="postComments_${pid}"></div>
      </div>
    </div>`;
  }).join('');
}

async function loadPostComments(postId, btn) {
  const el = document.getElementById('postComments_' + postId);
  if (el.innerHTML && el.style.display !== 'none') {
    el.style.display = 'none';
    btn.textContent = 'Load Top & Bottom Comments';
    return;
  }
  if (el.innerHTML) {
    el.style.display = 'block';
    btn.textContent = 'Hide Comments';
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Loading...';

  try {
    const res = await api('/comments/search', {
      link_id: 't3_' + postId, limit: 100,
      fields: 'id,body,subreddit,score,author,created_utc,link_id'
    });
    const comments = (res.data || []);

    if (!comments.length) {
      el.innerHTML = '<div class="empty-state" style="padding:12px">No comments found.</div>';
      btn.textContent = 'No Comments';
      btn.disabled = false;
      return;
    }

    comments.sort((a, b) => (b.score || 0) - (a.score || 0));
    const top3 = comments.slice(0, 3);
    const bottom3 = comments.filter(c => (c.score || 0) < 1).sort((a, b) => (a.score || 0) - (b.score || 0)).slice(0, 3);

    let html = '<div style="margin-top:12px">';
    html += '<strong style="color:var(--success)">Most Upvoted:</strong>';
    top3.forEach(c => {
      const cUrl = commentPermalink(c);
      html += `<a href="${cUrl}" target="_blank" class="clickable-comment"><div class="comment-card"><div class="comment-body comment-scroll">${escapeHtml(c.body || '')}</div>
        <div class="comment-meta"><span>u/${escapeHtml(c.author || '[deleted]')}</span><span>Score: ${(c.score||0).toLocaleString()}</span><span>${formatDate(c.created_utc)}</span></div></div></a>`;
    });
    if (bottom3.length) {
      html += '<strong style="color:var(--danger)">Most Downvoted:</strong>';
      bottom3.forEach(c => {
        const cUrl = commentPermalink(c);
        html += `<a href="${cUrl}" target="_blank" class="clickable-comment"><div class="comment-card" style="border-left-color:var(--danger)"><div class="comment-body comment-scroll">${escapeHtml(c.body || '')}</div>
          <div class="comment-meta"><span>u/${escapeHtml(c.author || '[deleted]')}</span><span>Score: ${(c.score||0).toLocaleString()}</span><span>${formatDate(c.created_utc)}</span></div></div></a>`;
      });
    }
    html += '<div style="font-size:0.75rem;color:var(--text-muted);margin-top:8px;font-style:italic">Note: Scores may not reflect final votes due to archival timing.</div>';
    html += '</div>';
    el.innerHTML = html;
    el.style.display = 'block';
    btn.textContent = 'Hide Comments';
  } catch (err) {
    el.innerHTML = `<div class="error-msg">Error loading comments: ${escapeHtml(err.message)}</div>`;
    btn.textContent = 'Retry';
  }
  btn.disabled = false;
}

// =============================================================================
// TAB 3: FAN SENTIMENT TIME SERIES
// Uses time_series endpoint (NOT comments/search/aggregate which times out)
// =============================================================================
async function loadSentiment() {
  const team1Sub = document.getElementById('sentimentTeam').value;
  const team2Sub = document.getElementById('sentimentTeam2').value;
  const after = document.getElementById('sentimentAfter').value;
  const before = document.getElementById('sentimentBefore').value;
  const precision = document.getElementById('sentimentPrecision').value;
  const chartsEl = document.getElementById('sentimentCharts');
  const resultsEl = document.getElementById('sentimentResults');
  showLoading(resultsEl);

  try {
    const team1Name = SUB_TO_TEAM[team1Sub.toLowerCase()] || team1Sub;

    async function fetchTeamData(sub) {
      // Use time_series for all three metrics (reliable, no 422 timeouts)
      const [posts, comments, scores] = await Promise.all([
        apiWithRetry('/time_series', { key: `r/${sub}/posts/count`, precision, after, before }),
        apiWithRetry('/time_series', { key: `r/${sub}/comments/count`, precision, after, before }),
        apiWithRetry('/time_series', { key: `r/${sub}/posts/sum_score`, precision, after, before })
      ]);
      return {
        posts: (posts.data || []).map(d => ({ date: d.date, value: d.value })),
        comments: (comments.data || []).map(d => ({ date: d.date, value: d.value })),
        scores: (scores.data || []).map(d => ({ date: d.date, value: d.value }))
      };
    }

    const data1 = await fetchTeamData(team1Sub);
    let data2 = null;
    let team2Name = '';
    if (team2Sub) {
      team2Name = SUB_TO_TEAM[team2Sub.toLowerCase()] || team2Sub;
      data2 = await fetchTeamData(team2Sub);
    }

    if (!team2Sub) {
      // Single team view
      const labels = data1.posts.map(d => formatDate(d.date));
      const postCounts = data1.posts.map(d => d.value || 0);
      const commentCounts = data1.comments.map(d => d.value || 0);
      const scoreValues = data1.scores.map(d => d.value || 0);

      chartsEl.innerHTML = '<div class="chart-container"><canvas id="sentimentMainChart"></canvas></div>';
      getOrCreateChart('sentimentMainChart', {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'Posts', data: postCounts, borderColor: '#f97316', backgroundColor: '#f9731622', fill: true, tension: 0.3, pointRadius: 2, yAxisID: 'y' },
            { label: 'Comments', data: commentCounts, borderColor: '#2563eb', backgroundColor: '#2563eb22', fill: true, tension: 0.3, pointRadius: 2, yAxisID: 'y' },
            { label: 'Total Score', data: scoreValues, borderColor: '#16a34a', backgroundColor: '#16a34a22', fill: false, tension: 0.3, pointRadius: 2, yAxisID: 'y1' }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          plugins: { title: { display: true, text: `r/${team1Sub} Activity — ${team1Name}`, color: '#1a1a2e' } },
          scales: {
            y: { type: 'linear', position: 'left', beginAtZero: true, title: { display: true, text: 'Count' } },
            y1: { type: 'linear', position: 'right', beginAtZero: true, title: { display: true, text: 'Score' }, grid: { drawOnChartArea: false } }
          }
        }
      });

      // NBA events in range
      const eventsInRange = NBA_EVENTS.filter(e => {
        const ed = new Date(e.date), ad = after ? new Date(after) : new Date(0), bd = before ? new Date(before) : new Date();
        return ed >= ad && ed <= bd;
      });
      resultsEl.innerHTML = eventsInRange.length > 0
        ? '<div class="card"><div class="card-title">NBA Events in Range</div>' + eventsInRange.map(e => `<span class="badge badge-orange" style="margin:4px">${e.label} (${e.date})</span>`).join('') + '</div>'
        : '';

    } else {
      // Compare mode
      const labels1 = data1.posts.map(d => formatDate(d.date));
      const labels2 = data2.posts.map(d => formatDate(d.date));
      const allLabels = [...new Set([...labels1, ...labels2])].sort();

      function alignData(dataArr, labels, allLabels) {
        const map = {};
        labels.forEach((l, i) => { map[l] = dataArr[i]?.value || 0; });
        return allLabels.map(l => map[l] || 0);
      }

      chartsEl.innerHTML = `<div class="compare-grid">
        <div class="chart-container"><canvas id="sentCompare1"></canvas></div>
        <div class="chart-container"><canvas id="sentCompare2"></canvas></div>
      </div>`;

      getOrCreateChart('sentCompare1', {
        type: 'line',
        data: {
          labels: allLabels,
          datasets: [
            { label: `r/${team1Sub} Posts`, data: alignData(data1.posts, labels1, allLabels), borderColor: '#f97316', tension: 0.3, pointRadius: 1 },
            { label: `r/${team2Sub} Posts`, data: alignData(data2.posts, labels2, allLabels), borderColor: '#2563eb', tension: 0.3, pointRadius: 1 }
          ]
        },
        options: { responsive: true, plugins: { title: { display: true, text: 'Posts Comparison', color: '#1a1a2e' } }, scales: { y: { beginAtZero: true } } }
      });

      getOrCreateChart('sentCompare2', {
        type: 'line',
        data: {
          labels: allLabels,
          datasets: [
            { label: `r/${team1Sub} Comments`, data: alignData(data1.comments, labels1, allLabels), borderColor: '#f97316', tension: 0.3, pointRadius: 1 },
            { label: `r/${team2Sub} Comments`, data: alignData(data2.comments, labels2, allLabels), borderColor: '#2563eb', tension: 0.3, pointRadius: 1 }
          ]
        },
        options: { responsive: true, plugins: { title: { display: true, text: 'Comments Comparison', color: '#1a1a2e' } }, scales: { y: { beginAtZero: true } } }
      });
      resultsEl.innerHTML = '';
    }
  } catch (err) {
    showError(resultsEl, 'Error loading sentiment data: ' + err.message);
  }
}

// =============================================================================
// TAB 4: PLAYER PERCEPTION — SENTIMENT ANALYSIS
// =============================================================================
async function analyzePerception() {
  const player = document.getElementById('perceptionPlayer').value.trim();
  if (!player) { toast('Please enter a player name.'); return; }
  const hours = parseInt(document.getElementById('perceptionRange').value);
  const after = hoursAgo(hours);
  const resultsEl = document.getElementById('perceptionResults');

  const selectedSubs = ['nba'];
  document.querySelectorAll('#perceptionTeams input:checked').forEach(cb => {
    if (selectedSubs.length < 6) selectedSubs.push(cb.value);
  });

  resultsEl.innerHTML = `<div class="loading-overlay"><div class="spinner"></div> <span id="perceptionProgress">Searching r/nba...</span></div>
    <div class="progress-bar"><div class="progress-fill" id="perceptionProgressFill"></div></div>`;

  try {
    const playerLower = player.toLowerCase();
    const playerTokens = [...playerLower.split(/\s+/), ...(PLAYER_NICKNAMES[playerLower] || [])];
    const subResults = {};
    let completed = 0;
    const skippedSubs = [];

    for (const sub of selectedSubs) {
      const pEl = document.getElementById('perceptionProgress');
      const fEl = document.getElementById('perceptionProgressFill');
      if (pEl) pEl.textContent = `Searching r/${sub}... (${completed+1}/${selectedSubs.length})`;
      if (fEl) fEl.style.width = `${(completed / selectedSubs.length) * 100}%`;
      try {
        const res = await apiWithRetry('/comments/search', { subreddit: sub, body: player, after, limit: 100 });
        subResults[sub] = res.data || [];
      } catch (e) {
        console.warn(`Skipping r/${sub}: ${e.message}`);
        subResults[sub] = [];
        skippedSubs.push(sub);
      }
      completed++;
      if (fEl) fEl.style.width = `${(completed / selectedSubs.length) * 100}%`;
    }

    const allComments = Object.values(subResults).flat();
    if (!allComments.length) { showEmpty(resultsEl, `No comments mentioning "${player}" found.`); return; }

    // Classify each comment
    const classified = allComments.map(c => {
      const sent = classifySentiment(c.body || '');
      return { ...c, ...sent, adjectives: extractAdjectives(c.body || '', playerTokens), comparisons: extractComparisons(c.body || '') };
    });

    const posCount = classified.filter(c => c.sentiment === 'positive').length;
    const negCount = classified.filter(c => c.sentiment === 'negative').length;
    const neutralCount = classified.filter(c => c.sentiment === 'neutral').length;
    const total = classified.length;
    const sentimentScore = total > 0 ? Math.round(((posCount - negCount) / total) * 100) : 0;

    // Adjective frequency
    const adjCounts = {};
    classified.forEach(c => c.adjectives.forEach(a => {
      if (!adjCounts[a]) adjCounts[a] = { count: 0, examples: [] };
      adjCounts[a].count++;
      if (adjCounts[a].examples.length < 1) adjCounts[a].examples.push(c);
    }));
    const topAdjs = Object.entries(adjCounts).sort((a, b) => b[1].count - a[1].count).slice(0, 25);

    // Comparisons
    const compCounts = {};
    classified.forEach(c => c.comparisons.forEach(comp => { compCounts[comp] = (compCounts[comp] || 0) + 1; }));
    const topComps = Object.entries(compCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);

    // Per-sub breakdown
    const subBreakdown = Object.entries(subResults).map(([sub, comments]) => {
      const cls = comments.map(c => classifySentiment(c.body || ''));
      const p = cls.filter(c => c.sentiment === 'positive').length;
      const n = cls.filter(c => c.sentiment === 'negative').length;
      const t = comments.length;
      return { sub, total: t, posP: t?Math.round(p/t*100):0, negP: t?Math.round(n/t*100):0, neuP: t?Math.round((t-p-n)/t*100):0, score: t?Math.round((p-n)/t*100):0 };
    });

    const positiveComments = [...classified].filter(c => c.sentiment === 'positive').sort((a, b) => b.posCount - a.posCount).slice(0, 10);
    const negativeComments = [...classified].filter(c => c.sentiment === 'negative').sort((a, b) => b.negCount - a.negCount).slice(0, 10);

    // Build HTML
    let html = '';
    if (skippedSubs.length) html += `<div class="error-msg">Could not fetch from r/${skippedSubs.join(', r/')}. Showing partial results.</div>`;

    // Donut + Gauge row
    html += `<div class="compare-grid" style="margin-bottom:16px">
      <div class="chart-container"><canvas id="sentimentDonut"></canvas></div>
      <div class="chart-container sentiment-gauge">
        <div style="font-size:0.85rem;color:var(--text-secondary);text-transform:uppercase;margin-bottom:8px">Sentiment Score</div>
        <div class="gauge-score" style="color:${sentimentScore>=20?'var(--success)':sentimentScore<=-20?'var(--danger)':'#333'}">${sentimentScore>0?'+':''}${sentimentScore}</div>
        <div class="gauge-bar"><div class="gauge-marker" style="left:${50+sentimentScore/2}%"></div></div>
        <div style="display:flex;justify-content:space-between;width:80%;font-size:0.7rem;color:var(--text-muted);margin-top:6px"><span>-100</span><span>0</span><span>+100</span></div>
        <div class="stat-grid" style="width:100%;margin-top:16px">
          <div class="stat-card"><div class="stat-value" style="color:var(--success)">${posCount}</div><div class="stat-label">Positive</div></div>
          <div class="stat-card"><div class="stat-value" style="color:var(--danger)">${negCount}</div><div class="stat-label">Negative</div></div>
          <div class="stat-card"><div class="stat-value">${neutralCount}</div><div class="stat-label">Neutral</div></div>
        </div>
      </div>
    </div>`;

    // Adjective word cloud + table
    if (topAdjs.length) {
      html += `<div class="card"><div class="card-title">How Reddit Describes "${escapeHtml(player)}"</div>
        <div class="word-cloud">${topAdjs.map(([word, data]) => {
          const info = ADJECTIVE_MAP[word] || { sentiment: 'neutral' };
          const size = 0.8 + (data.count / (topAdjs[0]?.[1]?.count || 1)) * 1.2;
          const color = info.sentiment === 'positive' ? 'var(--success)' : info.sentiment === 'negative' ? 'var(--danger)' : '#2563eb';
          return `<span class="word-tag" style="font-size:${size}rem;color:${color};border-color:${color}40">${escapeHtml(word)} (${data.count})</span>`;
        }).join('')}</div>
        <div class="table-wrap"><table><thead><tr><th>Word</th><th>Count</th><th>Sentiment</th><th>Example</th></tr></thead>
        <tbody>${topAdjs.map(([word, data]) => {
          const info = ADJECTIVE_MAP[word] || { sentiment: 'neutral' };
          const badge = info.sentiment === 'positive' ? 'badge-green' : info.sentiment === 'negative' ? 'badge-red' : 'badge-blue';
          const ex = data.examples[0];
          return `<tr><td><strong>${escapeHtml(word)}</strong></td><td>${data.count}</td><td><span class="badge ${badge}">${info.sentiment}</span></td>
            <td style="max-width:400px">${ex ? `<a href="${commentPermalink(ex)}" target="_blank" style="font-size:0.8rem">${escapeHtml(truncate(ex.body||'',120))}</a>` : ''}</td></tr>`;
        }).join('')}</tbody></table></div></div>`;
    }

    // Comparisons
    if (topComps.length) {
      html += `<div class="card"><div class="card-title">Player Comparisons</div>
        <p style="color:var(--text-secondary);font-size:0.85rem;margin-bottom:8px">Reddit compares ${escapeHtml(player)} to:</p>
        <div class="word-cloud">${topComps.map(([name, count]) =>
          `<span class="word-tag" style="font-size:${0.9+(count/(topComps[0]?.[1]||1))*0.8}rem">"The next ${escapeHtml(name)}" (${count})</span>`
        ).join('')}</div></div>`;
    }

    // Positive / Negative columns
    html += `<div class="compare-grid">
      <div class="card"><div class="card-title" style="color:var(--success)">Most Positive Comments</div>
        ${positiveComments.length ? positiveComments.map(c =>
          `<a href="${commentPermalink(c)}" target="_blank" class="clickable-comment"><div class="comment-card"><div class="comment-body comment-scroll">${escapeHtml(c.body||'')}</div>
            <div class="comment-meta"><span>u/${escapeHtml(c.author||'[deleted]')}</span><span>Score: ${(c.score||0).toLocaleString()}</span><span>r/${escapeHtml(c.subreddit)}</span><span>${formatDate(c.created_utc)}</span></div></div></a>`
        ).join('') : '<div class="empty-state">None found.</div>'}
      </div>
      <div class="card"><div class="card-title" style="color:var(--danger)">Most Negative Comments</div>
        ${negativeComments.length ? negativeComments.map(c =>
          `<a href="${commentPermalink(c)}" target="_blank" class="clickable-comment"><div class="comment-card" style="border-left-color:var(--danger)"><div class="comment-body comment-scroll">${escapeHtml(c.body||'')}</div>
            <div class="comment-meta"><span>u/${escapeHtml(c.author||'[deleted]')}</span><span>Score: ${(c.score||0).toLocaleString()}</span><span>r/${escapeHtml(c.subreddit)}</span><span>${formatDate(c.created_utc)}</span></div></div></a>`
        ).join('') : '<div class="empty-state">None found.</div>'}
      </div>
    </div>`;

    // Sub breakdown
    html += `<div class="card"><div class="card-title">Perception by Subreddit</div>
      <div class="chart-container"><canvas id="subSentimentChart"></canvas></div>
      <div class="table-wrap"><table><thead><tr><th>Subreddit</th><th>Comments</th><th>Positive</th><th>Negative</th><th>Neutral</th><th>Score</th></tr></thead>
      <tbody>${subBreakdown.map(s => `<tr><td>r/${escapeHtml(s.sub)}</td><td>${s.total}</td>
        <td style="color:var(--success)">${s.posP}%</td><td style="color:var(--danger)">${s.negP}%</td><td>${s.neuP}%</td>
        <td style="color:${s.score>=0?'var(--success)':'var(--danger)'};font-weight:600">${s.score>0?'+':''}${s.score}</td></tr>`).join('')}</tbody></table></div>
    </div>`;

    resultsEl.innerHTML = html;

    getOrCreateChart('sentimentDonut', {
      type: 'doughnut',
      data: { labels: ['Positive','Negative','Neutral'], datasets: [{ data: [posCount, negCount, neutralCount], backgroundColor: ['#16a34a','#dc2626','#9ca3af'], borderWidth: 0 }] },
      options: { responsive: true, plugins: { title: { display: true, text: `"${player}" Sentiment Breakdown`, color: '#333' }, legend: { position: 'bottom' } } }
    });

    getOrCreateChart('subSentimentChart', {
      type: 'bar',
      data: { labels: subBreakdown.map(s => 'r/'+s.sub), datasets: [
        { label: 'Positive %', data: subBreakdown.map(s => s.posP), backgroundColor: '#16a34a' },
        { label: 'Negative %', data: subBreakdown.map(s => s.negP), backgroundColor: '#dc2626' },
        { label: 'Neutral %', data: subBreakdown.map(s => s.neuP), backgroundColor: '#9ca3af' }
      ]},
      options: { responsive: true, plugins: { title: { display: true, text: 'Sentiment by Subreddit', color: '#333' } }, scales: { x: { stacked: true }, y: { stacked: true, max: 100 } } }
    });
  } catch (err) {
    showError(resultsEl, 'Error analyzing perception: ' + err.message);
  }
}

// =============================================================================
// TAB 5: SOCIAL MEDIA CONTENT SOURCING
// =============================================================================
let socialData = [];

async function findViralTakes() {
  const query = document.getElementById('socialQuery').value.trim();
  if (!query) { toast('Please enter a search keyword.'); return; }
  const minScore = parseInt(document.getElementById('socialMinScore').value) || 100;
  const after = document.getElementById('socialAfter').value;
  const before = document.getElementById('socialBefore').value;
  const resultsEl = document.getElementById('socialResults');
  showLoading(resultsEl);

  try {
    const res = await apiWithRetry('/comments/search', {
      subreddit: 'nba', body: query, after, before, limit: 100,
      fields: 'id,body,subreddit,score,author,created_utc,link_id'
    });
    socialData = (res.data || []).filter(c => (c.score || 0) >= minScore)
      .sort((a, b) => (b.score || 0) - (a.score || 0));

    if (!socialData.length) {
      showEmpty(resultsEl, `No comments found with score >= ${minScore}. Try lowering the threshold.`);
      return;
    }

    resultsEl.innerHTML = `<p style="color:var(--text-secondary);margin-bottom:12px">${socialData.length} viral takes found (score >= ${minScore})</p>` +
      socialData.map((c, i) => {
        return `<a href="${commentPermalink(c)}" target="_blank" class="clickable-comment"><div class="comment-card">
          <div class="comment-body comment-scroll">${escapeHtml(c.body || '')}</div>
          <div class="comment-meta">
            <span>u/${escapeHtml(c.author)}</span>
            <span>Score: ${(c.score||0).toLocaleString()}</span>
            <span>r/${escapeHtml(c.subreddit)}</span>
            <span>${formatDate(c.created_utc)}</span>
          </div>
        </div></a>
        <div class="comment-actions" style="margin-bottom:8px">
          <button class="btn btn-sm btn-secondary" onclick="event.preventDefault();copySocialComment(${i})">Copy for Twitter</button>
          <button class="btn btn-sm btn-secondary" onclick="event.preventDefault();copySocialComment(${i})">Copy for Bluesky</button>
        </div>`;
      }).join('');
  } catch (err) {
    showError(resultsEl, 'Error finding viral takes: ' + err.message);
  }
}

function copySocialComment(index) {
  const c = socialData[index];
  if (!c) return;
  const text = `"${truncate(c.body || '', 250).replace(/\n/g, ' ')}" — u/${c.author} on r/${c.subreddit}`;
  copyToClipboard(text);
}

function batchExportSocial(count) {
  if (!socialData.length) { toast('No data to export. Run a search first.'); return; }
  const items = socialData.slice(0, count);
  const content = items.map((c, i) =>
    `--- ${i + 1}. Score: ${c.score} | u/${c.author} on r/${c.subreddit} | ${formatDate(c.created_utc)} ---\n\n"${(c.body || '').trim()}"\n\nPermalink: ${commentPermalink(c)}\n`
  ).join('\n');
  downloadFile(content, `viral_takes_top${count}.txt`, 'text/plain');
  toast(`Exported top ${Math.min(count, items.length)} takes!`);
}

// =============================================================================
// TAB 6: SUBREDDIT GROWTH & TEAM POPULARITY
// Uses time_series for comment counts (NOT comments/search/aggregate which 422s)
// =============================================================================
let growthResults = null;
const growthSortState = {};

async function loadGrowthData() {
  const resultsEl = document.getElementById('growthResults');
  const progressEl = document.getElementById('growthProgress');
  const fillEl = document.getElementById('growthProgressFill');
  progressEl.style.display = 'block';
  showLoading(resultsEl);

  const cachedGrowth = Cache.get('growth_all_teams');
  if (cachedGrowth) {
    growthResults = cachedGrowth;
    progressEl.style.display = 'none';
    renderGrowthData();
    toast('Loaded from cache!');
    return;
  }

  const teams = Object.entries(NBA_TEAMS);
  const results = [];
  let completed = 0;

  try {
    for (const [team, sub] of teams) {
      try {
        // Use posts aggregate + time_series for comments (avoids 422)
        const [recent, previous, recentCommentsTs] = await Promise.all([
          api('/posts/search/aggregate', { subreddit: sub, aggregate: 'created_utc', frequency: 'month', after: daysAgo(90) }),
          api('/posts/search/aggregate', { subreddit: sub, aggregate: 'created_utc', frequency: 'month', after: daysAgo(180), before: daysAgo(90) }),
          api('/time_series', { key: `r/${sub}/comments/count`, precision: 'month', after: daysAgo(90) })
        ]);

        const recentPosts = (recent.data || []).reduce((s, d) => s + parseInt(d.count || 0), 0);
        const prevPosts = (previous.data || []).reduce((s, d) => s + parseInt(d.count || 0), 0);
        const recentCommentCount = (recentCommentsTs.data || []).reduce((s, d) => s + (d.value || 0), 0);
        const growth = prevPosts > 0 ? Math.round(((recentPosts - prevPosts) / prevPosts) * 100) : 0;

        results.push({ team, sub, recentPosts, recentComments: recentCommentCount, totalActivity: recentPosts + recentCommentCount, growth, avgPostScore: 0 });
      } catch (e) {
        console.warn(`Growth data failed for ${team}:`, e.message);
        results.push({ team, sub, recentPosts: 0, recentComments: 0, totalActivity: 0, growth: 0, avgPostScore: 0 });
      }
      completed++;
      fillEl.style.width = `${(completed / teams.length) * 100}%`;
      resultsEl.innerHTML = `<div class="loading-overlay"><div class="spinner"></div> Loading ${completed}/${teams.length} teams...</div>`;
    }

    growthResults = results;
    Cache.set('growth_all_teams', results);
    progressEl.style.display = 'none';
    renderGrowthData();
  } catch (err) {
    progressEl.style.display = 'none';
    showError(resultsEl, 'Error loading growth data: ' + err.message);
  }
}

const GROWTH_COLUMNS = [
  { field: 'team', label: 'Team' },
  { field: 'sub', label: 'Subreddit', render: t => `<a href="https://reddit.com/r/${t.sub}" target="_blank">r/${t.sub}</a>` },
  { field: 'totalActivity', label: 'Activity (90d)', render: t => t.totalActivity.toLocaleString() },
  { field: 'growth', label: 'Growth %', defaultSort: true, render: t => {
    const cls = t.growth > 0 ? 'badge-green' : t.growth < 0 ? 'badge-red' : 'badge-orange';
    return `<span class="badge ${cls}">${t.growth > 0 ? '+' : ''}${t.growth}%</span>`;
  }},
  { field: 'recentPosts', label: 'Posts', render: t => t.recentPosts.toLocaleString() },
  { field: 'recentComments', label: 'Comments', render: t => t.recentComments.toLocaleString() }
];

function renderGrowthData() {
  if (!growthResults) return;
  const sorted = [...growthResults].sort((a, b) => b.growth - a.growth);

  // Chart
  document.getElementById('growthChart').style.display = 'block';
  const top15 = sorted.slice(0, 15);
  getOrCreateChart('growthChartCanvas', {
    type: 'bar',
    data: {
      labels: top15.map(t => t.team.replace(/.*\s/, '')),
      datasets: [{
        label: 'Growth %',
        data: top15.map(t => t.growth),
        backgroundColor: top15.map(t => t.growth > 0 ? '#16a34a' : '#f97316')
      }]
    },
    options: {
      responsive: true, indexAxis: 'y',
      plugins: { title: { display: true, text: 'Fastest Growing NBA Fanbases on Reddit (90-day)', color: '#1a1a2e' } },
      scales: { x: { beginAtZero: true } }
    }
  });

  growthSortState._sort = null;
  renderSortableTable('growthResults', growthResults, GROWTH_COLUMNS, growthSortState);
}

// =============================================================================
// TAB 7: HISTORICAL REACTIONS
// =============================================================================
let historyData = [];

async function searchHistory() {
  const query = document.getElementById('historyQuery').value.trim();
  if (!query) { toast('Please enter a search query.'); return; }
  const after = document.getElementById('historyAfter').value;
  const before = document.getElementById('historyBefore').value;
  const resultsEl = document.getElementById('historyResults');
  document.getElementById('historyBrief').style.display = 'none';
  showLoading(resultsEl);

  try {
    const res = await api('/posts/search', {
      subreddit: 'nba', query, after, before, limit: 'auto'
    });
    historyData = (res.data || []).sort((a, b) => ((b.score||0) + (b.num_comments||0)) - ((a.score||0) + (a.num_comments||0)));

    if (!historyData.length) { showEmpty(resultsEl, 'No posts found for that query and date range.'); return; }

    resultsEl.innerHTML = historyData.slice(0, 50).map(p => {
      const thumb = renderThumbnail(p);
      return `<div class="card" style="display:flex;gap:12px;align-items:flex-start">
        ${thumb ? `<div>${thumb}</div>` : ''}
        <div style="flex:1;min-width:0">
          <div class="card-title"><a href="${postPermalink(p)}" target="_blank">${escapeHtml(p.title)}</a></div>
          <div class="comment-meta">
            <span>u/${escapeHtml(p.author)}</span>
            <span>Score: ${(p.score||0).toLocaleString()}</span>
            <span>${(p.num_comments||0).toLocaleString()} comments</span>
            <span>${formatDate(p.created_utc)}</span>
            <span class="badge badge-orange">r/${escapeHtml(p.subreddit)}</span>
          </div>
          ${p.selftext ? `<div class="comment-scroll" style="margin-top:8px;color:var(--text-secondary);font-size:0.85rem">${escapeHtml(p.selftext)}</div>` : ''}
          <button class="btn btn-sm btn-secondary" style="margin-top:8px" onclick="expandThread('${(p.id||'').replace('t3_','')}', this)">Expand Thread</button>
          <div id="thread-${(p.id||'').replace('t3_','')}" class="expand-content"></div>
        </div>
      </div>`;
    }).join('');
  } catch (err) {
    showError(resultsEl, 'Error searching history: ' + err.message);
  }
}

function parseTreeComments(data) {
  if (!data || !data.length) return [];
  return data.filter(item => item.kind === 't1' && item.data).map(item => item.data);
}

async function expandThread(postId, btn) {
  const threadEl = document.getElementById('thread-' + postId);
  if (threadEl.classList.contains('open')) {
    threadEl.classList.remove('open');
    btn.textContent = 'Expand Thread';
    return;
  }
  btn.textContent = 'Loading...';
  btn.disabled = true;
  try {
    const res = await api('/comments/tree', { link_id: 't3_' + postId, limit: 20 });
    const comments = parseTreeComments(res.data);
    if (!comments.length) {
      threadEl.innerHTML = '<div class="empty-state">No comments found.</div>';
    } else {
      threadEl.innerHTML = comments.slice(0, 15).map(c => {
        const cLink = c.link_id ? commentPermalink(c) : '#';
        return `<a href="${cLink}" target="_blank" class="clickable-comment"><div class="comment-card">
          <div class="comment-body comment-scroll">${escapeHtml(c.body || '')}</div>
          <div class="comment-meta">
            <span>u/${escapeHtml(c.author || '[deleted]')}</span>
            <span>Score: ${c.score || 0}</span>
            <span>${formatDate(c.created_utc)}</span>
          </div>
        </div></a>`;
      }).join('');
    }
    threadEl.classList.add('open');
    btn.textContent = 'Collapse Thread';
  } catch (err) {
    threadEl.innerHTML = `<div class="error-msg">Could not load comments: ${escapeHtml(err.message)}</div>`;
    threadEl.classList.add('open');
    btn.textContent = 'Retry';
  }
  btn.disabled = false;
}

async function generateBrief() {
  if (!historyData.length) { toast('Search for posts first.'); return; }
  const briefEl = document.getElementById('historyBrief');
  briefEl.style.display = 'block';
  briefEl.innerHTML = '<div class="loading-overlay"><div class="spinner"></div> Generating article brief...</div>';

  const topPosts = historyData.slice(0, 5);
  let brief = `# Reddit Reaction Brief: "${document.getElementById('historyQuery').value}"\n`;
  brief += `Generated: ${new Date().toLocaleDateString()}\n\n`;

  for (let i = 0; i < topPosts.length; i++) {
    const p = topPosts[i];
    brief += `## ${i + 1}. ${p.title}\n`;
    brief += `- Score: ${(p.score||0).toLocaleString()} | Comments: ${(p.num_comments||0).toLocaleString()} | Date: ${formatDate(p.created_utc)}\n`;
    brief += `- Link: ${postPermalink(p)}\n\n`;

    try {
      const res = await api('/comments/tree', { link_id: (p.id || '').startsWith('t3_') ? p.id : 't3_' + p.id, limit: 5 });
      const comments = parseTreeComments(res.data).slice(0, 3);
      comments.forEach((c, j) => {
        brief += `> **Top Comment ${j + 1}** (Score: ${c.score || 0}, u/${c.author || 'deleted'}):\n`;
        brief += `> ${(c.body || '').trim()}\n\n`;
      });
    } catch {
      brief += `> *Could not load comments for this post.*\n\n`;
    }
    brief += `---\n\n`;
  }

  briefEl.innerHTML = `
    <div class="card">
      <div class="card-title">Article Brief <button class="btn btn-sm" onclick="copyToClipboard(document.getElementById('briefContent').textContent)">Copy</button></div>
      <div class="markdown-brief" id="briefContent">${escapeHtml(brief)}</div>
    </div>`;
}

// =============================================================================
// INITIALIZATION
// =============================================================================
function init() {
  const today = new Date().toISOString().split('T')[0];
  const sixHoursAgoDate = today; // Same day for date inputs

  document.getElementById('rumorAfter').value = sixHoursAgoDate;
  document.getElementById('rumorBefore').value = today;
  document.getElementById('socialAfter').value = sixHoursAgoDate;
  document.getElementById('socialBefore').value = today;
  document.getElementById('sentimentAfter').value = sixHoursAgoDate;
  document.getElementById('sentimentBefore').value = today;
  document.getElementById('historyAfter').value = sixHoursAgoDate;
  document.getElementById('historyBefore').value = today;

  const teamOptions = Object.entries(NBA_TEAMS).map(([team, sub]) =>
    `<option value="${sub}">${team}</option>`).join('');
  document.getElementById('sentimentTeam').innerHTML = teamOptions;
  document.getElementById('sentimentTeam2').innerHTML = '<option value="">-- None (Single Team) --</option>' + teamOptions;
  document.getElementById('perceptionTeams').innerHTML = Object.entries(NBA_TEAMS).map(([team, sub]) =>
    `<label class="team-checkbox"><input type="checkbox" value="${sub}"> ${team}</label>`).join('');

  checkApiStatus();

  document.addEventListener('keydown', e => {
    if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
      const panel = e.target.closest('.tab-panel');
      if (!panel) return;
      const btn = panel.querySelector('.btn');
      if (btn) btn.click();
    }
  });

  // Auto-load Trend Detection tab on startup
  setTimeout(() => loadTrends(), 300);
}

async function checkApiStatus() {
  try {
    await fetch(API_BASE + '/posts/search?limit=1');
    document.getElementById('apiDot').className = 'api-dot online';
    document.getElementById('apiStatusText').textContent = 'API Online';
  } catch {
    document.getElementById('apiDot').className = 'api-dot offline';
    document.getElementById('apiStatusText').textContent = 'API Offline';
  }
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
