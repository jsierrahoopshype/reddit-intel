<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HoopsHype Reddit Intel</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
/* ===== RESET & BASE ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-tertiary: #e9ecef;
  --bg-card: #ffffff;
  --text-primary: #1a1a2e;
  --text-secondary: #6c757d;
  --text-muted: #adb5bd;
  --accent: #f97316;
  --accent-hover: #ea580c;
  --accent-dim: #fff7ed;
  --border: #dee2e6;
  --success: #16a34a;
  --danger: #dc2626;
  --warning: #ca8a04;
  --info: #2563eb;
  --radius: 8px;
  --shadow: 0 1px 3px rgba(0,0,0,0.08), 0 1px 2px rgba(0,0,0,0.06);
}
html { font-size: 14px; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg-secondary);
  color: var(--text-primary);
  min-height: 100vh;
  line-height: 1.5;
}
a { color: var(--accent); text-decoration: none; }
a:hover { color: var(--accent-hover); text-decoration: underline; }

/* ===== HEADER ===== */
.header {
  background: var(--bg-primary);
  border-bottom: 1px solid var(--border);
  padding: 12px 24px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  z-index: 100;
  box-shadow: var(--shadow);
}
.header-left { display: flex; align-items: center; gap: 12px; }
.logo { font-size: 1.4rem; font-weight: 700; color: var(--accent); }
.logo-sub { font-size: 0.85rem; color: var(--text-secondary); }
.api-status {
  display: flex; align-items: center; gap: 6px;
  font-size: 0.8rem; color: var(--text-secondary);
  background: var(--bg-secondary); padding: 4px 10px;
  border-radius: 20px; border: 1px solid var(--border);
}
.api-dot {
  width: 8px; height: 8px; border-radius: 50%;
  background: var(--text-muted);
}
.api-dot.online { background: var(--success); }
.api-dot.offline { background: var(--danger); }

/* ===== TAB NAV ===== */
.tab-nav {
  display: flex;
  background: var(--bg-primary);
  border-bottom: 2px solid var(--border);
  overflow-x: auto;
  scrollbar-width: thin;
}
.tab-btn {
  background: none; border: none; color: var(--text-secondary);
  padding: 12px 18px; cursor: pointer; white-space: nowrap;
  font-size: 0.85rem; font-weight: 500;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
  margin-bottom: -2px;
}
.tab-btn:hover { color: var(--text-primary); background: var(--bg-secondary); }
.tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

/* ===== MAIN CONTENT ===== */
.main { max-width: 1400px; margin: 0 auto; padding: 20px; }
.tab-panel { display: none; }
.tab-panel.active { display: block; }

/* ===== FORM CONTROLS ===== */
.controls {
  display: flex; flex-wrap: wrap; gap: 10px;
  align-items: flex-end;
  margin-bottom: 20px;
  padding: 16px;
  background: var(--bg-primary);
  border-radius: var(--radius);
  border: 1px solid var(--border);
  box-shadow: var(--shadow);
}
.form-group { display: flex; flex-direction: column; gap: 4px; }
.form-group label {
  font-size: 0.75rem; color: var(--text-secondary);
  text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
}
input[type="text"], input[type="date"], input[type="number"], select {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  padding: 8px 12px;
  border-radius: var(--radius);
  font-size: 0.9rem;
  min-width: 160px;
}
input:focus, select:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-dim); }
.btn {
  background: var(--accent);
  color: #fff; border: none;
  padding: 8px 18px; border-radius: var(--radius);
  cursor: pointer; font-weight: 600; font-size: 0.85rem;
  transition: background 0.2s;
  white-space: nowrap;
}
.btn:hover { background: var(--accent-hover); }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-sm { padding: 5px 12px; font-size: 0.8rem; }
.btn-secondary { background: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--bg-tertiary); }
.btn-success { background: var(--success); }
.btn-info { background: var(--info); }

/* ===== TABLE ===== */
.table-wrap { overflow-x: auto; margin: 16px 0; }
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}
th {
  background: var(--bg-secondary);
  color: var(--text-secondary);
  text-transform: uppercase;
  font-size: 0.75rem;
  letter-spacing: 0.5px;
  text-align: left;
  padding: 10px 12px;
  white-space: nowrap;
  cursor: pointer;
  user-select: none;
  border-bottom: 2px solid var(--border);
}
th:hover { color: var(--accent); }
th .sort-arrow { font-size: 0.65rem; margin-left: 3px; }
td {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
}
tr:hover { background: var(--bg-secondary); }

/* ===== CARDS ===== */
.card {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin-bottom: 16px;
  box-shadow: var(--shadow);
}
.card-title {
  font-size: 1rem; font-weight: 600;
  margin-bottom: 8px; color: #333;
}
.card-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 16px;
}
.stat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 12px;
  margin-bottom: 20px;
}
.stat-card {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 14px;
  text-align: center;
  box-shadow: var(--shadow);
}
.stat-value { font-size: 1.8rem; font-weight: 700; color: #333; }
.stat-label { font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; margin-top: 4px; }

/* ===== CHART ===== */
.chart-container {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 16px;
  margin: 16px 0;
  position: relative;
  box-shadow: var(--shadow);
}
.chart-container canvas { max-height: 350px; }

/* ===== LOADING & STATES ===== */
.spinner {
  display: inline-block;
  width: 20px; height: 20px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.loading-overlay {
  display: flex; align-items: center; justify-content: center;
  gap: 10px; padding: 40px;
  color: var(--text-secondary);
}
.progress-bar {
  width: 100%; height: 6px;
  background: var(--bg-tertiary);
  border-radius: 3px;
  overflow: hidden;
  margin: 10px 0;
}
.progress-fill {
  height: 100%;
  background: var(--accent);
  border-radius: 3px;
  transition: width 0.3s;
  width: 0%;
}
.empty-state {
  text-align: center; padding: 40px;
  color: var(--text-muted);
}
.error-msg {
  background: #fef2f2;
  color: var(--danger);
  border: 1px solid #fecaca;
  padding: 10px 16px;
  border-radius: var(--radius);
  margin: 10px 0;
  font-size: 0.85rem;
}
.toast {
  position: fixed; bottom: 20px; right: 20px;
  background: var(--bg-primary); color: var(--text-primary);
  padding: 10px 20px; border-radius: var(--radius);
  border: 1px solid var(--accent);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 1000; font-size: 0.85rem;
  animation: fadeInUp 0.3s;
}
@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ===== COMMENT CARD ===== */
.comment-card {
  background: var(--bg-secondary);
  border-left: 3px solid var(--accent);
  padding: 12px 16px;
  margin: 8px 0;
  border-radius: 0 var(--radius) var(--radius) 0;
}
.comment-meta {
  font-size: 0.75rem; color: var(--text-secondary);
  margin-top: 6px;
  display: flex; gap: 12px; flex-wrap: wrap;
  align-items: center;
}
.comment-body { white-space: pre-wrap; word-break: break-word; }
.comment-actions { display: flex; gap: 6px; margin-top: 8px; }

/* ===== BADGES ===== */
.badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.7rem;
  font-weight: 600;
  text-transform: uppercase;
}
.badge-orange { background: var(--accent-dim); color: var(--accent); }
.badge-green { background: #dcfce7; color: var(--success); }
.badge-blue { background: #dbeafe; color: var(--info); }
.badge-red { background: #fef2f2; color: var(--danger); }

/* ===== WORD CLOUD ===== */
.word-cloud {
  display: flex; flex-wrap: wrap; gap: 6px;
  padding: 16px; justify-content: center;
}
.word-tag {
  background: var(--bg-secondary);
  padding: 4px 10px;
  border-radius: 14px;
  font-size: 0.8rem;
  border: 1px solid var(--border);
}

/* ===== TEAM SELECT GRID ===== */
.team-select-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 6px;
  max-height: 200px;
  overflow-y: auto;
  padding: 8px;
  background: var(--bg-secondary);
  border-radius: var(--radius);
  border: 1px solid var(--border);
}
.team-checkbox { display: flex; align-items: center; gap: 4px; font-size: 0.8rem; cursor: pointer; }
.team-checkbox input { accent-color: var(--accent); }

/* ===== EXPAND ===== */
.expandable { cursor: pointer; }
.expand-content { display: none; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--border); }
.expand-content.open { display: block; }

/* ===== FOOTER ===== */
.footer {
  text-align: center; padding: 20px;
  color: var(--text-muted); font-size: 0.75rem;
  border-top: 1px solid var(--border);
  margin-top: 40px;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .header { flex-direction: column; gap: 8px; padding: 10px; }
  .tab-btn { padding: 10px 12px; font-size: 0.8rem; }
  .controls { flex-direction: column; }
  .form-group { width: 100%; }
  input[type="text"], input[type="date"], input[type="number"], select { width: 100%; min-width: unset; }
  .card-grid { grid-template-columns: 1fr; }
  .stat-grid { grid-template-columns: repeat(2, 1fr); }
  .main { padding: 10px; }
}

/* ===== MARKDOWN BRIEF ===== */
.markdown-brief {
  background: var(--bg-secondary);
  padding: 16px;
  border-radius: var(--radius);
  white-space: pre-wrap;
  font-family: 'Courier New', monospace;
  font-size: 0.85rem;
  max-height: 500px;
  overflow-y: auto;
  border: 1px solid var(--border);
}
.compare-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
@media (max-width: 768px) {
  .compare-grid { grid-template-columns: 1fr; }
}

/* ===== THUMBNAILS ===== */
.thumb-img {
  width: 80px; height: 80px;
  object-fit: cover;
  border-radius: 4px;
  flex-shrink: 0;
}

/* ===== SCROLLABLE COMMENTS ===== */
.comment-scroll {
  max-height: 300px;
  overflow-y: auto;
}

/* ===== TREND CARDS ===== */
.trend-card {
  display: flex;
  gap: 12px;
  align-items: flex-start;
}
.trend-card-body {
  flex: 1;
  min-width: 0;
}
.trend-card-title {
  font-weight: 600;
  margin-bottom: 4px;
}
.trend-card-title a { color: #333; }
.trend-card-title a:hover { color: var(--accent); }
.sort-controls {
  display: flex; gap: 6px; margin-bottom: 12px; flex-wrap: wrap;
}
.sort-controls .btn.active-sort {
  background: var(--accent); color: #fff;
}
</style>
</head>
<body>

<!-- ===== HEADER ===== -->
<header class="header">
  <div class="header-left">
    <div>
      <div class="logo">HoopsHype Reddit Intel</div>
      <div class="logo-sub">NBA Reddit Intelligence Dashboard</div>
    </div>
  </div>
  <div class="api-status">
    <span class="api-dot" id="apiDot"></span>
    <span id="apiStatusText">Checking API...</span>
  </div>
</header>

<!-- ===== TAB NAV ===== -->
<nav class="tab-nav" id="tabNav">
  <button class="tab-btn" data-tab="rumors">Rumor & Buzz Tracker</button>
  <button class="tab-btn active" data-tab="trends">Trend Detection</button>
  <button class="tab-btn" data-tab="sentiment">Fan Sentiment</button>
  <button class="tab-btn" data-tab="perception">Player Perception</button>
  <button class="tab-btn" data-tab="social">Content Sourcing</button>
  <button class="tab-btn" data-tab="growth">Subreddit Growth</button>
  <button class="tab-btn" data-tab="history">Historical Reactions</button>
</nav>

<!-- ===== MAIN ===== -->
<main class="main">

<!-- TAB 1: RUMOR TRACKER -->
<div class="tab-panel" id="tab-rumors">
  <div class="controls">
    <div class="form-group">
      <label>Keyword / Player</label>
      <input type="text" id="rumorQuery" placeholder='e.g. "Jimmy Butler trade"'>
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="rumorAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="rumorBefore">
    </div>
    <button class="btn" onclick="searchRumors()">Search</button>
    <button class="btn btn-secondary" onclick="exportRumorCSV()">Export CSV</button>
  </div>
  <div id="rumorChart" class="chart-container" style="display:none"><canvas id="rumorChartCanvas"></canvas></div>
  <div id="rumorStats"></div>
  <div id="rumorTableWrap"><div class="empty-state">Enter a keyword and click Search to find NBA rumors and buzz.</div></div>
</div>

<!-- TAB 2: TREND DETECTION -->
<div class="tab-panel active" id="tab-trends">
  <div class="controls">
    <div class="form-group">
      <label>Time Period</label>
      <select id="trendPeriod">
        <option value="1" selected>Last 24 Hours</option>
        <option value="7">Last 7 Days</option>
        <option value="30">Last 30 Days</option>
        <option value="90">Last 90 Days</option>
      </select>
    </div>
    <button class="btn" onclick="loadTrends()">Analyze Trends</button>
  </div>
  <div id="trendStats"></div>
  <div id="topBottomComments"></div>
  <div id="trendChart" class="chart-container" style="display:none"><canvas id="trendChartCanvas"></canvas></div>
  <div id="trendUnderserved" style="display:none"></div>
  <div id="trendResults"><div class="empty-state">Select a time period and click Analyze to detect trending topics on r/nba.</div></div>
</div>

<!-- TAB 3: FAN SENTIMENT -->
<div class="tab-panel" id="tab-sentiment">
  <div class="controls">
    <div class="form-group">
      <label>Team</label>
      <select id="sentimentTeam"></select>
    </div>
    <div class="form-group">
      <label>Compare With</label>
      <select id="sentimentTeam2"><option value="">-- None --</option></select>
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="sentimentAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="sentimentBefore">
    </div>
    <div class="form-group">
      <label>Precision</label>
      <select id="sentimentPrecision">
        <option value="day" selected>Daily</option>
        <option value="week">Weekly</option>
        <option value="month">Monthly</option>
      </select>
    </div>
    <button class="btn" onclick="loadSentiment()">Load Data</button>
  </div>
  <div id="sentimentCharts"></div>
  <div id="sentimentResults"><div class="empty-state">Select a team and date range to view fan activity trends.</div></div>
</div>

<!-- TAB 4: PLAYER PERCEPTION -->
<div class="tab-panel" id="tab-perception">
  <div class="controls">
    <div class="form-group">
      <label>Player Name</label>
      <input type="text" id="perceptionPlayer" placeholder="e.g. LeBron James">
    </div>
    <div class="form-group">
      <label>Date Range</label>
      <select id="perceptionRange">
        <option value="1" selected>Last 24 Hours</option>
        <option value="7">Last 7 Days</option>
        <option value="30">Last 30 Days</option>
        <option value="90">Last 90 Days</option>
      </select>
    </div>
    <button class="btn" onclick="analyzePerception()">Analyze</button>
  </div>
  <div class="form-group" style="margin-bottom:16px">
    <label>Select Team Subreddits (up to 5)</label>
    <div class="team-select-grid" id="perceptionTeams"></div>
  </div>
  <div id="perceptionResults"><div class="empty-state">Enter a player name and select subreddits to analyze perception across fanbases.</div></div>
</div>

<!-- TAB 5: SOCIAL CONTENT -->
<div class="tab-panel" id="tab-social">
  <div class="controls">
    <div class="form-group">
      <label>Keyword / Player</label>
      <input type="text" id="socialQuery" placeholder='e.g. "Wembanyama"'>
    </div>
    <div class="form-group">
      <label>Min Score</label>
      <input type="number" id="socialMinScore" value="100" min="1">
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="socialAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="socialBefore">
    </div>
    <button class="btn" onclick="findViralTakes()">Find Viral Takes</button>
    <button class="btn btn-secondary" onclick="batchExportSocial(10)">Export Top 10</button>
    <button class="btn btn-secondary" onclick="batchExportSocial(25)">Export Top 25</button>
    <button class="btn btn-secondary" onclick="batchExportSocial(50)">Export Top 50</button>
  </div>
  <div id="socialResults"><div class="empty-state">Search for viral takes to source content for social media.</div></div>
</div>

<!-- TAB 6: SUBREDDIT GROWTH -->
<div class="tab-panel" id="tab-growth">
  <div class="controls">
    <button class="btn" onclick="loadGrowthData()">Load All Team Data</button>
    <span class="form-group" style="flex:1">
      <div class="progress-bar" id="growthProgress" style="display:none"><div class="progress-fill" id="growthProgressFill"></div></div>
    </span>
  </div>
  <div id="growthChart" class="chart-container" style="display:none"><canvas id="growthChartCanvas"></canvas></div>
  <div id="growthResults"><div class="empty-state">Click "Load All Team Data" to fetch activity data for all 30 NBA team subreddits. This makes many API calls and may take a minute.</div></div>
</div>

<!-- TAB 7: HISTORICAL REACTIONS -->
<div class="tab-panel" id="tab-history">
  <div class="controls">
    <div class="form-group">
      <label>Search Query</label>
      <input type="text" id="historyQuery" placeholder='e.g. "Harden trade"'>
    </div>
    <div class="form-group">
      <label>From</label>
      <input type="date" id="historyAfter">
    </div>
    <div class="form-group">
      <label>To</label>
      <input type="date" id="historyBefore">
    </div>
    <button class="btn" onclick="searchHistory()">Search</button>
    <button class="btn btn-secondary" onclick="generateBrief()">Generate Article Brief</button>
  </div>
  <div id="historyResults"><div class="empty-state">Search for any NBA event to see how Reddit reacted. Try "Kawhi Clippers" or "2019 draft".</div></div>
  <div id="historyBrief" style="display:none"></div>
</div>

</main>

<!-- ===== FOOTER ===== -->
<footer class="footer">
  Built for HoopsHype editorial research. Data via <a href="https://arctic-shift.photon-reddit.com" target="_blank">Arctic Shift</a>.
</footer>

<script>
// =============================================================================
// CONFIGURATION
// =============================================================================
const API_BASE = 'https://arctic-shift.photon-reddit.com/api';
const CACHE_TTL = 3600000; // 1 hour
const RATE_LIMIT_MS = 500;

const NBA_TEAMS = {
  "Atlanta Hawks": "AtlantaHawks",
  "Boston Celtics": "bostonceltics",
  "Brooklyn Nets": "GoNets",
  "Charlotte Hornets": "CharlotteHornets",
  "Chicago Bulls": "chicagobulls",
  "Cleveland Cavaliers": "clevelandcavs",
  "Dallas Mavericks": "Mavericks",
  "Denver Nuggets": "denvernuggets",
  "Detroit Pistons": "DetroitPistons",
  "Golden State Warriors": "warriors",
  "Houston Rockets": "rockets",
  "Indiana Pacers": "pacers",
  "LA Clippers": "LAClippers",
  "Los Angeles Lakers": "lakers",
  "Memphis Grizzlies": "memphisgrizzlies",
  "Miami Heat": "heat",
  "Milwaukee Bucks": "MkeBucks",
  "Minnesota Timberwolves": "timberwolves",
  "New Orleans Pelicans": "NOLAPelicans",
  "New York Knicks": "NYKnicks",
  "Oklahoma City Thunder": "Thunder",
  "Orlando Magic": "OrlandoMagic",
  "Philadelphia 76ers": "sixers",
  "Phoenix Suns": "suns",
  "Portland Trail Blazers": "ripcity",
  "Sacramento Kings": "kings",
  "San Antonio Spurs": "NBASpurs",
  "Toronto Raptors": "torontoraptors",
  "Utah Jazz": "UtahJazz",
  "Washington Wizards": "washingtonwizards"
};

const SUB_TO_TEAM = {};
Object.entries(NBA_TEAMS).forEach(([team, sub]) => { SUB_TO_TEAM[sub.toLowerCase()] = team; });

const TOPIC_KEYWORDS = {
  trade: ['trade','traded','trading','deal','swap','package','assets'],
  GOAT: ['goat','greatest','all-time','all time','legacy','mount rushmore'],
  draft: ['draft','pick','prospect','lottery','combine','mock draft'],
  'free agency': ['free agent','free agency','signing','sign','unrestricted','restricted'],
  rookie: ['rookie','roty','first year','debut'],
  MVP: ['mvp','most valuable','award','frontrunner'],
  injury: ['injury','injured','acl','torn','surgery','rehab','out for','sidelined','day-to-day'],
  contract: ['contract','extension','max','supermax','salary','cap space','money']
};

const NBA_EVENTS = [
  { date: '2026-02-05', label: 'Trade Deadline' },
  { date: '2026-06-25', label: 'NBA Draft' },
  { date: '2026-06-30', label: 'Free Agency' },
  { date: '2025-10-22', label: 'Season Start' },
  { date: '2026-04-13', label: 'Playoffs Start' }
];

const STOPWORDS = new Set(['the','a','an','is','are','was','were','be','been','being','have','has','had',
  'do','does','did','will','would','could','should','may','might','shall','can','need','must',
  'to','of','in','for','on','with','at','by','from','as','into','through','during','before',
  'after','above','below','between','out','off','over','under','again','further','then','once',
  'here','there','when','where','why','how','all','both','each','few','more','most','other',
  'some','such','no','nor','not','only','own','same','so','than','too','very','just','about',
  'up','down','and','but','or','if','it','its','he','she','they','them','his','her','their',
  'this','that','these','those','i','me','my','we','us','our','you','your','what','which','who',
  'whom','get','got','like','really','think','know','make','go','going','even','still','also',
  'much','many','well','way','back','good','new','first','last','long','great','little','right',
  'old','big','high','different','small','large','next','one','two','dont','doesnt','didnt',
  'thats','hes','shes','theyre','youre','im','wont','cant','because','been','said','game',
  'player','team','season','year','nba','play','time','point','guy','people']);

// =============================================================================
// UTILITIES: Rate Limiter
// =============================================================================
const RateLimiter = (() => {
  let lastCall = 0;
  return async () => {
    const now = Date.now();
    const wait = RATE_LIMIT_MS - (now - lastCall);
    if (wait > 0) await new Promise(r => setTimeout(r, wait));
    lastCall = Date.now();
  };
})();

// =============================================================================
// UTILITIES: Cache
// =============================================================================
const Cache = {
  get(key) {
    try {
      const item = localStorage.getItem('rhi_' + key);
      if (!item) return null;
      const { data, ts } = JSON.parse(item);
      if (Date.now() - ts > CACHE_TTL) { localStorage.removeItem('rhi_' + key); return null; }
      return data;
    } catch { return null; }
  },
  set(key, data) {
    try {
      localStorage.setItem('rhi_' + key, JSON.stringify({ data, ts: Date.now() }));
    } catch { /* storage full */ }
  }
};

// =============================================================================
// UTILITIES: API Client (with console debug logging)
// =============================================================================
async function api(endpoint, params = {}) {
  const filtered = {};
  Object.entries(params).forEach(([k, v]) => {
    if (v !== undefined && v !== null && v !== '') filtered[k] = v;
  });
  const qs = new URLSearchParams(filtered).toString();
  const url = `${API_BASE}${endpoint}${qs ? '?' + qs : ''}`;

  // Debug: log every API call
  console.log('[API]', url);

  const cached = Cache.get(url);
  if (cached) { console.log('[API] Cache hit'); return cached; }

  await RateLimiter();
  const res = await fetch(url);
  if (!res.ok) {
    const body = await res.text().catch(() => '');
    console.error('[API] Error', res.status, body);
    throw new Error(`API error ${res.status}: ${body || res.statusText}`);
  }
  const json = await res.json();
  if (json.error) {
    console.error('[API] Response error:', json.error);
    throw new Error(`API: ${json.error}`);
  }
  Cache.set(url, json);
  return json;
}

// =============================================================================
// UTILITIES: Helpers
// =============================================================================
function formatDate(epoch) {
  if (!epoch) return '';
  const d = new Date(typeof epoch === 'number' ? epoch * 1000 : epoch);
  return d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
}

function formatDateISO(epoch) {
  const d = new Date(typeof epoch === 'number' ? epoch * 1000 : epoch);
  return d.toISOString().split('T')[0];
}

function daysAgo(n) {
  const d = new Date();
  d.setDate(d.getDate() - n);
  return d.toISOString().split('T')[0];
}

function truncate(str, len) {
  if (!str) return '';
  return str.length > len ? str.substring(0, len) + '...' : str;
}

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

function renderThumbnail(post) {
  const t = post.thumbnail || '';
  if (t && !['self','default','nsfw','spoiler',''].includes(t) && t.startsWith('http')) {
    return `<img src="${escapeHtml(t)}" class="thumb-img" onerror="this.style.display='none'" alt="">`;
  }
  const url = (post.url || '');
  if (/\.(jpg|jpeg|png|gif|webp)(\?|$)/i.test(url)) {
    return `<img src="${escapeHtml(url)}" class="thumb-img" onerror="this.style.display='none'" alt="">`;
  }
  if (/youtube\.com|youtu\.be/i.test(url)) return '<span class="badge badge-red">YT</span>';
  if (/streamable\.com/i.test(url)) return '<span class="badge badge-blue">Video</span>';
  if (/twitter\.com|x\.com/i.test(url)) return '<span class="badge badge-blue">Tweet</span>';
  return '';
}

function postPermalink(post) {
  return `https://www.reddit.com/r/${post.subreddit}/comments/${(post.id || '').replace('t3_','')}/`;
}

function commentPermalink(comment) {
  const linkId = (comment.link_id || '').replace('t3_', '');
  const commentId = (comment.id || '').replace('t1_', '');
  return `https://www.reddit.com/r/${comment.subreddit}/comments/${linkId}/_/${commentId}/`;
}

function showLoading(el) {
  el.innerHTML = '<div class="loading-overlay"><div class="spinner"></div> Loading...</div>';
}

function showError(el, msg) {
  el.innerHTML = `<div class="error-msg">${escapeHtml(msg)}</div>`;
}

function showEmpty(el, msg) {
  el.innerHTML = `<div class="empty-state">${escapeHtml(msg)}</div>`;
}

function toast(msg) {
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 2500);
}

async function copyToClipboard(text) {
  try {
    await navigator.clipboard.writeText(text);
    toast('Copied to clipboard!');
  } catch {
    toast('Copy failed — try manually.');
  }
}

function downloadFile(content, filename, type = 'text/csv') {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

// Chart.js defaults for light theme
Chart.defaults.color = '#6c757d';
Chart.defaults.borderColor = '#dee2e6';
Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif';

const charts = {};
function getOrCreateChart(canvasId, config) {
  if (charts[canvasId]) { charts[canvasId].destroy(); }
  const ctx = document.getElementById(canvasId).getContext('2d');
  charts[canvasId] = new Chart(ctx, config);
  return charts[canvasId];
}

const CHART_COLORS = ['#f97316','#2563eb','#16a34a','#ca8a04','#dc2626','#7c3aed','#db2777','#0891b2'];

// =============================================================================
// GENERIC SORTABLE TABLE
// =============================================================================
function renderSortableTable(containerId, data, columns, state) {
  if (!state._sort) { state._sort = columns.find(c => c.defaultSort)?.field || columns[0].field; state._asc = false; }
  const sorted = [...data].sort((a, b) => {
    let va = a[state._sort], vb = b[state._sort];
    if (va == null) va = typeof vb === 'number' ? 0 : '';
    if (vb == null) vb = typeof va === 'number' ? 0 : '';
    if (typeof va === 'string') { va = va.toLowerCase(); vb = (vb+'').toLowerCase(); }
    if (va < vb) return state._asc ? -1 : 1;
    if (va > vb) return state._asc ? 1 : -1;
    return 0;
  });

  const el = document.getElementById(containerId);
  el.innerHTML = `<div class="table-wrap"><table>
    <thead><tr>${columns.map(col => {
      const arrow = state._sort === col.field ? (state._asc ? ' <span class="sort-arrow">▲</span>' : ' <span class="sort-arrow">▼</span>') : '';
      return `<th data-sort="${col.field}">${col.label}${arrow}</th>`;
    }).join('')}</tr></thead>
    <tbody>${sorted.map(row => `<tr>${columns.map(col =>
      `<td>${col.render ? col.render(row) : escapeHtml(String(row[col.field] ?? ''))}</td>`
    ).join('')}</tr>`).join('')}</tbody>
  </table></div>`;

  el.querySelectorAll('th[data-sort]').forEach(th => {
    th.addEventListener('click', () => {
      const f = th.dataset.sort;
      if (state._sort === f) state._asc = !state._asc;
      else { state._sort = f; state._asc = false; }
      renderSortableTable(containerId, data, columns, state);
    });
  });
}

// =============================================================================
// TAB NAVIGATION
// =============================================================================
function showTab(tabId) {
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tabId));
  document.querySelectorAll('.tab-panel').forEach(p => p.classList.toggle('active', p.id === 'tab-' + tabId));
}

document.getElementById('tabNav').addEventListener('click', e => {
  if (e.target.classList.contains('tab-btn')) showTab(e.target.dataset.tab);
});

// =============================================================================
// TAB 1: RUMOR & BUZZ TRACKER
// =============================================================================
let rumorData = [];
const rumorSortState = {};
const RUMOR_SUBS = ['nba', 'nbadiscussion', 'NBA_TradeDiscussions'];

const RUMOR_COLUMNS = [
  { field: 'thumbnail', label: 'Media', render: p => renderThumbnail(p) },
  { field: 'title', label: 'Title', render: p => `<a href="${postPermalink(p)}" target="_blank">${escapeHtml(p.title)}</a>` },
  { field: 'subreddit', label: 'Subreddit', render: p => `<span class="badge badge-orange">r/${escapeHtml(p.subreddit)}</span>` },
  { field: 'score', label: 'Score', defaultSort: true, render: p => (p.score||0).toLocaleString() },
  { field: 'num_comments', label: 'Comments', render: p => (p.num_comments||0).toLocaleString() },
  { field: 'created_utc', label: 'Date', render: p => formatDate(p.created_utc) }
];

async function searchRumors() {
  const query = document.getElementById('rumorQuery').value.trim();
  if (!query) { toast('Please enter a search keyword.'); return; }
  const after = document.getElementById('rumorAfter').value;
  const before = document.getElementById('rumorBefore').value;
  const statsEl = document.getElementById('rumorStats');
  const tableEl = document.getElementById('rumorTableWrap');
  showLoading(tableEl);

  try {
    const allPosts = [];
    for (const sub of RUMOR_SUBS) {
      const res = await api('/posts/search', {
        subreddit: sub, query, after, before, limit: 100
      });
      if (res.data) allPosts.push(...res.data);
    }
    rumorData = allPosts;

    if (!rumorData.length) { showEmpty(tableEl, 'No results found.'); statsEl.innerHTML = ''; return; }

    statsEl.innerHTML = `<div class="stat-grid">
      <div class="stat-card"><div class="stat-value">${rumorData.length}</div><div class="stat-label">Posts Found</div></div>
      <div class="stat-card"><div class="stat-value">${rumorData.reduce((s,p) => s + (p.score||0), 0).toLocaleString()}</div><div class="stat-label">Total Score</div></div>
      <div class="stat-card"><div class="stat-value">${rumorData.reduce((s,p) => s + (p.num_comments||0), 0).toLocaleString()}</div><div class="stat-label">Total Comments</div></div>
    </div>`;

    rumorSortState._sort = null; // reset
    renderSortableTable('rumorTableWrap', rumorData, RUMOR_COLUMNS, rumorSortState);

    // Time series chart
    try {
      const aggRes = await api('/posts/search/aggregate', {
        subreddit: 'nba', query, aggregate: 'created_utc',
        frequency: 'day', after, before
      });
      if (aggRes.data && aggRes.data.length > 0) {
        document.getElementById('rumorChart').style.display = 'block';
        const labels = aggRes.data.map(d => formatDate(d.created_utc));
        const values = aggRes.data.map(d => parseInt(d.count));
        getOrCreateChart('rumorChartCanvas', {
          type: 'line',
          data: {
            labels,
            datasets: [{
              label: `"${query}" mentions/day on r/nba`,
              data: values,
              borderColor: '#f97316',
              backgroundColor: '#f9731633',
              fill: true, tension: 0.3, pointRadius: 2
            }]
          },
          options: { responsive: true, plugins: { legend: { display: true } }, scales: { y: { beginAtZero: true } } }
        });
      }
    } catch (e) { console.warn('Chart aggregate failed:', e); }
  } catch (err) {
    showError(tableEl, 'Error fetching rumors: ' + err.message);
  }
}

function exportRumorCSV() {
  if (!rumorData.length) { toast('No data to export.'); return; }
  const header = 'Title,Subreddit,Score,Comments,Date,URL\n';
  const rows = rumorData.map(p =>
    `"${(p.title||'').replace(/"/g,'""')}",r/${p.subreddit},${p.score||0},${p.num_comments||0},${formatDateISO(p.created_utc)},${postPermalink(p)}`
  ).join('\n');
  downloadFile(header + rows, 'rumor_results.csv');
  toast('CSV exported!');
}

// =============================================================================
// TAB 2: TREND DETECTION & CONTENT IDEAS
// =============================================================================
let trendData = [];
let trendTopics = {};
let trendCardSort = { field: 'score', asc: false };

async function loadTrends() {
  const days = parseInt(document.getElementById('trendPeriod').value);
  const resultsEl = document.getElementById('trendResults');
  showLoading(resultsEl);

  try {
    const after = daysAgo(days);
    const res = await api('/posts/search', {
      subreddit: 'nba', after, limit: 100
    });
    trendData = (res.data || []).sort((a, b) => (b.score || 0) - (a.score || 0));

    // Categorize posts into topics
    trendTopics = {};
    Object.keys(TOPIC_KEYWORDS).forEach(t => { trendTopics[t] = { posts: [], totalScore: 0, totalComments: 0 }; });
    trendTopics['other'] = { posts: [], totalScore: 0, totalComments: 0 };

    trendData.forEach(post => {
      const titleLower = (post.title || '').toLowerCase();
      let matched = false;
      Object.entries(TOPIC_KEYWORDS).forEach(([topic, keywords]) => {
        if (keywords.some(kw => titleLower.includes(kw))) {
          trendTopics[topic].posts.push(post);
          trendTopics[topic].totalScore += (post.score || 0);
          trendTopics[topic].totalComments += (post.num_comments || 0);
          matched = true;
        }
      });
      if (!matched) {
        trendTopics['other'].posts.push(post);
        trendTopics['other'].totalScore += (post.score || 0);
        trendTopics['other'].totalComments += (post.num_comments || 0);
      }
    });

    // Stats
    document.getElementById('trendStats').innerHTML = `
      <div class="stat-grid">
        <div class="stat-card"><div class="stat-value">${trendData.length}</div><div class="stat-label">Posts Analyzed</div></div>
        <div class="stat-card"><div class="stat-value">${Object.keys(trendTopics).filter(t => trendTopics[t].posts.length > 0).length}</div><div class="stat-label">Topics Detected</div></div>
        <div class="stat-card"><div class="stat-value">${trendData.length > 0 ? Math.round(trendData.reduce((s,p) => s + (p.score||0), 0) / trendData.length).toLocaleString() : 0}</div><div class="stat-label">Avg Score</div></div>
      </div>`;

    // Bar chart
    const topicNames = Object.keys(trendTopics).filter(t => t !== 'other' && trendTopics[t].posts.length > 0);
    const engagement = topicNames.map(t => trendTopics[t].totalScore + trendTopics[t].totalComments);
    document.getElementById('trendChart').style.display = 'block';
    getOrCreateChart('trendChartCanvas', {
      type: 'bar',
      data: {
        labels: topicNames.map(t => t.charAt(0).toUpperCase() + t.slice(1)),
        datasets: [{
          label: 'Total Engagement (Score + Comments)',
          data: engagement,
          backgroundColor: CHART_COLORS.slice(0, topicNames.length)
        }]
      },
      options: { responsive: true, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true } } }
    });

    // Underserved topics
    const underserved = topicNames
      .filter(t => trendTopics[t].posts.length > 0)
      .map(t => ({ topic: t, count: trendTopics[t].posts.length, avgScore: Math.round(trendTopics[t].totalScore / trendTopics[t].posts.length), totalEngagement: trendTopics[t].totalScore + trendTopics[t].totalComments }))
      .sort((a, b) => b.avgScore - a.avgScore);
    const avgAvgScore = underserved.reduce((s, u) => s + u.avgScore, 0) / (underserved.length || 1);
    const highPerformers = underserved.filter(u => u.avgScore > avgAvgScore && u.count < trendData.length / Object.keys(trendTopics).length);
    const underEl = document.getElementById('trendUnderserved');
    if (highPerformers.length > 0) {
      underEl.style.display = 'block';
      underEl.innerHTML = `<div class="card"><div class="card-title">Underserved Topics (High Avg Score, Low Post Count)</div>
        <div class="table-wrap"><table><thead><tr><th>Topic</th><th>Post Count</th><th>Avg Score</th><th>Total Engagement</th></tr></thead>
        <tbody>${highPerformers.map(u => `<tr><td><span class="badge badge-green">${u.topic}</span></td><td>${u.count}</td><td>${u.avgScore.toLocaleString()}</td><td>${u.totalEngagement.toLocaleString()}</td></tr>`).join('')}</tbody></table></div></div>`;
    } else { underEl.style.display = 'none'; }

    // Load top & bottom comments for this time period
    loadTopBottomComments(after);

    // Unified "All Trending Content"
    resultsEl.innerHTML = `
      <h3 style="margin:20px 0 12px;color:#333;font-size:1.1rem">All Trending Content</h3>
      <div class="sort-controls">
        <button class="btn btn-sm active-sort" data-sort="score" onclick="sortTrendCards('score')">Score</button>
        <button class="btn btn-sm btn-secondary" data-sort="num_comments" onclick="sortTrendCards('num_comments')">Comments</button>
        <button class="btn btn-sm btn-secondary" data-sort="created_utc" onclick="sortTrendCards('created_utc')">Date</button>
      </div>
      <div id="trendCards"></div>`;
    trendCardSort = { field: 'score', asc: false };
    renderTrendCards();

  } catch (err) {
    showError(resultsEl, 'Error loading trends: ' + err.message);
  }
}

async function loadTopBottomComments(after) {
  const el = document.getElementById('topBottomComments');
  el.innerHTML = '<div class="card"><div class="loading-overlay"><div class="spinner"></div> Loading top & bottom comments on r/nba...</div></div>';

  try {
    // Fetch 100 comments and sort client-side (API only supports time-based sorting)
    const res = await api('/comments/search', { subreddit: 'nba', after, limit: 100 });
    const comments = (res.data || []).filter(c => c.body && c.body !== '[deleted]' && c.body !== '[removed]');

    if (!comments.length) {
      el.innerHTML = '<div class="card"><div class="empty-state">No comments found for this time period.</div></div>';
      return;
    }

    comments.sort((a, b) => (b.score || 0) - (a.score || 0));
    const top = comments[0];
    const bottom = comments[comments.length - 1];

    // Fetch post titles for context
    const postIds = [...new Set([top.link_id, bottom.link_id].filter(Boolean))];
    const postTitles = {};
    for (const linkId of postIds) {
      try {
        const pRes = await api('/posts/search', { ids: linkId.replace('t3_', ''), limit: 1 });
        if (pRes.data && pRes.data[0]) postTitles[linkId] = pRes.data[0].title;
      } catch (e) { /* ignore */ }
    }

    function renderHighlightComment(c, label, borderColor) {
      const permalink = commentPermalink(c);
      const postTitle = postTitles[c.link_id] || '';
      return `<div class="comment-card" style="border-left: 4px solid ${borderColor}; margin: 10px 0;">
        <div style="font-size:0.8rem;font-weight:600;color:${borderColor};margin-bottom:6px">${label}</div>
        <div class="comment-body">${escapeHtml(c.body || '')}</div>
        ${postTitle ? `<div style="margin-top:8px;font-size:0.8rem;color:var(--text-secondary)">On: <em>${escapeHtml(postTitle)}</em></div>` : ''}
        <div class="comment-meta">
          <span>u/${escapeHtml(c.author || '[deleted]')}</span>
          <span>Score: ${(c.score||0).toLocaleString()}</span>
          <span>${formatDate(c.created_utc)}</span>
          <a href="${permalink}" target="_blank" style="color:var(--accent)">View on Reddit</a>
        </div>
      </div>`;
    }

    el.innerHTML = `<div class="card">
      <div class="card-title">Top & Bottom Comments on r/nba</div>
      <p style="font-size:0.8rem;color:var(--text-secondary);margin-bottom:8px">Comment scores may not reflect final votes due to archival timing.</p>
      ${renderHighlightComment(top, 'MOST UPVOTED', '#22c55e')}
      ${renderHighlightComment(bottom, 'MOST DOWNVOTED', '#ef4444')}
    </div>`;
  } catch (err) {
    el.innerHTML = `<div class="card"><div class="error-msg">Error loading top/bottom comments: ${escapeHtml(err.message)}</div></div>`;
  }
}

function sortTrendCards(field) {
  if (trendCardSort.field === field) {
    trendCardSort.asc = !trendCardSort.asc;
  } else {
    trendCardSort.field = field;
    trendCardSort.asc = false;
  }
  // Update button styles
  document.querySelectorAll('.sort-controls .btn').forEach(btn => {
    const isActive = btn.dataset.sort === field;
    btn.className = isActive ? 'btn btn-sm active-sort' : 'btn btn-sm btn-secondary';
  });
  renderTrendCards();
}

function renderTrendCards() {
  const sorted = [...trendData].sort((a, b) => {
    const va = a[trendCardSort.field] || 0, vb = b[trendCardSort.field] || 0;
    return trendCardSort.asc ? va - vb : vb - va;
  });
  const cardsEl = document.getElementById('trendCards');
  if (!cardsEl) return;
  cardsEl.innerHTML = sorted.slice(0, 50).map(p => {
    const pid = (p.id || '').replace('t3_', '');
    const thumb = renderThumbnail(p);
    return `<div class="card trend-card">
      ${thumb ? `<div>${thumb}</div>` : ''}
      <div class="trend-card-body">
        <div class="trend-card-title"><a href="${postPermalink(p)}" target="_blank">${escapeHtml(p.title)}</a></div>
        <div class="comment-meta">
          <span>Score: ${(p.score||0).toLocaleString()}</span>
          <span>${(p.num_comments||0).toLocaleString()} comments</span>
          <span>${formatDate(p.created_utc)}</span>
          <span>u/${escapeHtml(p.author || '[deleted]')}</span>
        </div>
        <button class="btn btn-sm btn-secondary" style="margin-top:8px" onclick="loadPostComments('${pid}', this)">Load Top & Bottom Comments</button>
        <div id="postComments_${pid}"></div>
      </div>
    </div>`;
  }).join('');
}

async function loadPostComments(postId, btn) {
  const el = document.getElementById('postComments_' + postId);
  if (el.innerHTML && el.style.display !== 'none') {
    el.style.display = 'none';
    btn.textContent = 'Load Top & Bottom Comments';
    return;
  }
  if (el.innerHTML) {
    el.style.display = 'block';
    btn.textContent = 'Hide Comments';
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Loading...';

  try {
    const res = await api('/comments/search', {
      link_id: 't3_' + postId, limit: 100
    });
    const comments = (res.data || []).filter(c => c.body && c.body !== '[deleted]' && c.body !== '[removed]');

    if (!comments.length) {
      el.innerHTML = '<div class="empty-state" style="padding:12px">No comments found.</div>';
      btn.textContent = 'No Comments';
      btn.disabled = false;
      return;
    }

    comments.sort((a, b) => (b.score || 0) - (a.score || 0));
    const top = comments[0];
    const bottom = comments[comments.length - 1];

    let html = '<div style="margin-top:12px">';
    html += '<strong style="color:#22c55e">Most Upvoted:</strong>';
    html += `<div class="comment-card" style="border-left:3px solid #22c55e"><div class="comment-body">${escapeHtml(top.body || '')}</div>
      <div class="comment-meta"><span>u/${escapeHtml(top.author || '[deleted]')}</span><span>Score: ${(top.score||0).toLocaleString()}</span><span>${formatDate(top.created_utc)}</span>
      <a href="${commentPermalink(top)}" target="_blank" style="color:var(--accent)">View on Reddit</a></div></div>`;
    if ((bottom.score || 0) < (top.score || 0)) {
      html += '<strong style="color:#ef4444">Most Downvoted:</strong>';
      html += `<div class="comment-card" style="border-left:3px solid #ef4444"><div class="comment-body">${escapeHtml(bottom.body || '')}</div>
        <div class="comment-meta"><span>u/${escapeHtml(bottom.author || '[deleted]')}</span><span>Score: ${(bottom.score||0).toLocaleString()}</span><span>${formatDate(bottom.created_utc)}</span>
        <a href="${commentPermalink(bottom)}" target="_blank" style="color:var(--accent)">View on Reddit</a></div></div>`;
    }
    html += '<div style="font-size:0.75rem;color:var(--text-secondary);margin-top:6px;font-style:italic">Comment scores may not reflect final votes due to archival timing.</div>';
    html += '</div>';
    el.innerHTML = html;
    el.style.display = 'block';
    btn.textContent = 'Hide Comments';
  } catch (err) {
    el.innerHTML = `<div class="error-msg">Error loading comments: ${escapeHtml(err.message)}</div>`;
    btn.textContent = 'Retry';
  }
  btn.disabled = false;
}

// =============================================================================
// TAB 3: FAN SENTIMENT TIME SERIES
// Uses time_series endpoint (NOT comments/search/aggregate which times out)
// =============================================================================
async function loadSentiment() {
  const team1Sub = document.getElementById('sentimentTeam').value;
  const team2Sub = document.getElementById('sentimentTeam2').value;
  const after = document.getElementById('sentimentAfter').value;
  const before = document.getElementById('sentimentBefore').value;
  const precision = document.getElementById('sentimentPrecision').value;
  const chartsEl = document.getElementById('sentimentCharts');
  const resultsEl = document.getElementById('sentimentResults');
  showLoading(resultsEl);

  try {
    const team1Name = SUB_TO_TEAM[team1Sub.toLowerCase()] || team1Sub;

    async function fetchTeamData(sub) {
      // Use time_series for all three metrics (reliable, no 422 timeouts)
      const [posts, comments, scores] = await Promise.all([
        api('/time_series', { key: `r/${sub}/posts/count`, precision, after, before }),
        api('/time_series', { key: `r/${sub}/comments/count`, precision, after, before }),
        api('/time_series', { key: `r/${sub}/posts/sum_score`, precision, after, before })
      ]);
      return {
        posts: (posts.data || []).map(d => ({ date: d.date, value: d.value })),
        comments: (comments.data || []).map(d => ({ date: d.date, value: d.value })),
        scores: (scores.data || []).map(d => ({ date: d.date, value: d.value }))
      };
    }

    const data1 = await fetchTeamData(team1Sub);
    let data2 = null;
    let team2Name = '';
    if (team2Sub) {
      team2Name = SUB_TO_TEAM[team2Sub.toLowerCase()] || team2Sub;
      data2 = await fetchTeamData(team2Sub);
    }

    if (!team2Sub) {
      // Single team view
      const labels = data1.posts.map(d => formatDate(d.date));
      const postCounts = data1.posts.map(d => d.value || 0);
      const commentCounts = data1.comments.map(d => d.value || 0);
      const scoreValues = data1.scores.map(d => d.value || 0);

      chartsEl.innerHTML = '<div class="chart-container"><canvas id="sentimentMainChart"></canvas></div>';
      getOrCreateChart('sentimentMainChart', {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'Posts', data: postCounts, borderColor: '#f97316', backgroundColor: '#f9731622', fill: true, tension: 0.3, pointRadius: 2, yAxisID: 'y' },
            { label: 'Comments', data: commentCounts, borderColor: '#2563eb', backgroundColor: '#2563eb22', fill: true, tension: 0.3, pointRadius: 2, yAxisID: 'y' },
            { label: 'Total Score', data: scoreValues, borderColor: '#16a34a', backgroundColor: '#16a34a22', fill: false, tension: 0.3, pointRadius: 2, yAxisID: 'y1' }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          plugins: { title: { display: true, text: `r/${team1Sub} Activity — ${team1Name}`, color: '#1a1a2e' } },
          scales: {
            y: { type: 'linear', position: 'left', beginAtZero: true, title: { display: true, text: 'Count' } },
            y1: { type: 'linear', position: 'right', beginAtZero: true, title: { display: true, text: 'Score' }, grid: { drawOnChartArea: false } }
          }
        }
      });

      // NBA events in range
      const eventsInRange = NBA_EVENTS.filter(e => {
        const ed = new Date(e.date), ad = after ? new Date(after) : new Date(0), bd = before ? new Date(before) : new Date();
        return ed >= ad && ed <= bd;
      });
      resultsEl.innerHTML = eventsInRange.length > 0
        ? '<div class="card"><div class="card-title">NBA Events in Range</div>' + eventsInRange.map(e => `<span class="badge badge-orange" style="margin:4px">${e.label} (${e.date})</span>`).join('') + '</div>'
        : '';

    } else {
      // Compare mode
      const labels1 = data1.posts.map(d => formatDate(d.date));
      const labels2 = data2.posts.map(d => formatDate(d.date));
      const allLabels = [...new Set([...labels1, ...labels2])].sort();

      function alignData(dataArr, labels, allLabels) {
        const map = {};
        labels.forEach((l, i) => { map[l] = dataArr[i]?.value || 0; });
        return allLabels.map(l => map[l] || 0);
      }

      chartsEl.innerHTML = `<div class="compare-grid">
        <div class="chart-container"><canvas id="sentCompare1"></canvas></div>
        <div class="chart-container"><canvas id="sentCompare2"></canvas></div>
      </div>`;

      getOrCreateChart('sentCompare1', {
        type: 'line',
        data: {
          labels: allLabels,
          datasets: [
            { label: `r/${team1Sub} Posts`, data: alignData(data1.posts, labels1, allLabels), borderColor: '#f97316', tension: 0.3, pointRadius: 1 },
            { label: `r/${team2Sub} Posts`, data: alignData(data2.posts, labels2, allLabels), borderColor: '#2563eb', tension: 0.3, pointRadius: 1 }
          ]
        },
        options: { responsive: true, plugins: { title: { display: true, text: 'Posts Comparison', color: '#1a1a2e' } }, scales: { y: { beginAtZero: true } } }
      });

      getOrCreateChart('sentCompare2', {
        type: 'line',
        data: {
          labels: allLabels,
          datasets: [
            { label: `r/${team1Sub} Comments`, data: alignData(data1.comments, labels1, allLabels), borderColor: '#f97316', tension: 0.3, pointRadius: 1 },
            { label: `r/${team2Sub} Comments`, data: alignData(data2.comments, labels2, allLabels), borderColor: '#2563eb', tension: 0.3, pointRadius: 1 }
          ]
        },
        options: { responsive: true, plugins: { title: { display: true, text: 'Comments Comparison', color: '#1a1a2e' } }, scales: { y: { beginAtZero: true } } }
      });
      resultsEl.innerHTML = '';
    }
  } catch (err) {
    showError(resultsEl, 'Error loading sentiment data: ' + err.message);
  }
}

// =============================================================================
// TAB 4: PLAYER PERCEPTION ANALYZER
// =============================================================================
async function analyzePerception() {
  const player = document.getElementById('perceptionPlayer').value.trim();
  if (!player) { toast('Please enter a player name.'); return; }
  const days = parseInt(document.getElementById('perceptionRange').value);
  const after = daysAgo(days);
  const resultsEl = document.getElementById('perceptionResults');

  const selectedSubs = ['nba'];
  document.querySelectorAll('#perceptionTeams input:checked').forEach(cb => {
    if (selectedSubs.length < 6) selectedSubs.push(cb.value);
  });

  resultsEl.innerHTML = `<div class="loading-overlay"><div class="spinner"></div> <span id="perceptionProgress">Analyzing r/nba...</span></div>
    <div class="progress-bar"><div class="progress-fill" id="perceptionProgressFill"></div></div>`;

  try {
    const subResults = {};
    let completed = 0;

    for (const sub of selectedSubs) {
      const progressEl = document.getElementById('perceptionProgress');
      const fillEl = document.getElementById('perceptionProgressFill');
      if (progressEl) progressEl.textContent = `Analyzing r/${sub}... (${completed + 1}/${selectedSubs.length})`;
      if (fillEl) fillEl.style.width = `${(completed / selectedSubs.length) * 100}%`;

      let retries = 0;
      const maxRetries = 2;
      let success = false;

      while (retries <= maxRetries && !success) {
        try {
          const res = await api('/comments/search', {
            subreddit: sub, body: player, after, limit: 25,
            fields: 'id,body,subreddit,score,author,created_utc,link_id'
          });
          subResults[sub] = res.data || [];
          success = true;
        } catch (e) {
          retries++;
          if (retries > maxRetries) {
            console.warn(`Skipping r/${sub}: ${e.message}`);
            subResults[sub] = [];
          } else {
            const delay = 1000 * Math.pow(2, retries - 1);
            console.log(`Retrying r/${sub} in ${delay}ms (attempt ${retries}/${maxRetries})`);
            await new Promise(r => setTimeout(r, delay));
          }
        }
      }
      completed++;
      if (fillEl) fillEl.style.width = `${(completed / selectedSubs.length) * 100}%`;
    }

    // Per-subreddit stats
    const subStats = Object.entries(subResults).map(([sub, comments]) => {
      const scores = comments.map(c => c.score || 0);
      return {
        sub, count: comments.length,
        avgScore: scores.length ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length) : 0,
        maxComment: comments.reduce((best, c) => (!best || (c.score||0) > (best.score||0)) ? c : best, null),
        minComment: comments.reduce((worst, c) => (!worst || (c.score||0) < (worst.score||0)) ? c : worst, null)
      };
    });

    // Word frequency
    const allComments = Object.values(subResults).flat();
    const wordCounts = {};
    const playerWords = player.toLowerCase().split(/\s+/);
    allComments.forEach(c => {
      const words = (c.body || '').toLowerCase().replace(/[^a-z0-9\s'-]/g, '').split(/\s+/);
      const seen = new Set();
      words.forEach(w => {
        if (w.length > 2 && !STOPWORDS.has(w) && !playerWords.includes(w) && !seen.has(w)) {
          wordCounts[w] = (wordCounts[w] || 0) + 1;
          seen.add(w);
        }
      });
    });
    const topWords = Object.entries(wordCounts).sort((a, b) => b[1] - a[1]).slice(0, 20);

    let html = '<div class="chart-container"><canvas id="perceptionChart"></canvas></div>';
    html += `<div class="card"><div class="card-title">Top Words Associated with "${escapeHtml(player)}"</div>
      <div class="word-cloud">${topWords.map(([w, c]) => {
        const size = 0.7 + (c / (topWords[0]?.[1] || 1)) * 0.8;
        return `<span class="word-tag" style="font-size:${size}rem">${escapeHtml(w)} (${c})</span>`;
      }).join('')}</div></div>`;

    subStats.forEach(s => {
      html += `<div class="card"><div class="card-title">r/${escapeHtml(s.sub)} <span class="badge badge-blue">${s.count} comments</span> <span class="badge badge-orange">Avg: ${s.avgScore}</span></div>`;
      if (s.maxComment) {
        html += `<div class="comment-card"><div class="comment-body comment-scroll">${escapeHtml(s.maxComment.body || '')}</div>
          <div class="comment-meta"><span>u/${escapeHtml(s.maxComment.author)}</span><span>Score: ${s.maxComment.score}</span><span>${formatDate(s.maxComment.created_utc)}</span>
          <a href="${commentPermalink(s.maxComment)}" target="_blank">View</a></div></div>`;
      }
      if (s.minComment && s.minComment !== s.maxComment) {
        html += `<div class="comment-card" style="border-left-color:var(--danger)"><div class="comment-body comment-scroll">${escapeHtml(s.minComment.body || '')}</div>
          <div class="comment-meta"><span>u/${escapeHtml(s.minComment.author)}</span><span>Score: ${s.minComment.score}</span><span>${formatDate(s.minComment.created_utc)}</span>
          <a href="${commentPermalink(s.minComment)}" target="_blank">View</a></div></div>`;
      }
      html += '</div>';
    });

    resultsEl.innerHTML = html;
    getOrCreateChart('perceptionChart', {
      type: 'bar',
      data: {
        labels: subStats.map(s => 'r/' + s.sub),
        datasets: [{ label: 'Average Comment Score', data: subStats.map(s => s.avgScore), backgroundColor: CHART_COLORS.slice(0, subStats.length) }]
      },
      options: { responsive: true, plugins: { title: { display: true, text: `"${player}" Perception by Subreddit`, color: '#1a1a2e' } }, scales: { y: { beginAtZero: true } } }
    });
  } catch (err) {
    showError(resultsEl, 'Error analyzing perception: ' + err.message);
  }
}

// =============================================================================
// TAB 5: SOCIAL MEDIA CONTENT SOURCING
// =============================================================================
let socialData = [];

async function findViralTakes() {
  const query = document.getElementById('socialQuery').value.trim();
  if (!query) { toast('Please enter a search keyword.'); return; }
  const minScore = parseInt(document.getElementById('socialMinScore').value) || 100;
  const after = document.getElementById('socialAfter').value;
  const before = document.getElementById('socialBefore').value;
  const resultsEl = document.getElementById('socialResults');
  showLoading(resultsEl);

  try {
    const res = await api('/comments/search', {
      subreddit: 'nba', body: query, after, before, limit: 100,
      fields: 'id,body,subreddit,score,author,created_utc,link_id'
    });
    socialData = (res.data || []).filter(c => (c.score || 0) >= minScore)
      .sort((a, b) => (b.score || 0) - (a.score || 0));

    if (!socialData.length) {
      showEmpty(resultsEl, `No comments found with score >= ${minScore}. Try lowering the threshold.`);
      return;
    }

    resultsEl.innerHTML = `<p style="color:var(--text-secondary);margin-bottom:12px">${socialData.length} viral takes found (score >= ${minScore})</p>` +
      socialData.map((c, i) => {
        return `<div class="comment-card">
          <div class="comment-body comment-scroll">${escapeHtml(c.body || '')}</div>
          <div class="comment-meta">
            <span>u/${escapeHtml(c.author)}</span>
            <span>Score: ${(c.score||0).toLocaleString()}</span>
            <span>r/${escapeHtml(c.subreddit)}</span>
            <span>${formatDate(c.created_utc)}</span>
            <a href="${commentPermalink(c)}" target="_blank">View</a>
          </div>
          <div class="comment-actions">
            <button class="btn btn-sm btn-secondary" onclick="copySocialComment(${i})">Copy for Twitter</button>
            <button class="btn btn-sm btn-secondary" onclick="copySocialComment(${i})">Copy for Bluesky</button>
          </div>
        </div>`;
      }).join('');
  } catch (err) {
    showError(resultsEl, 'Error finding viral takes: ' + err.message);
  }
}

function copySocialComment(index) {
  const c = socialData[index];
  if (!c) return;
  const text = `"${truncate(c.body || '', 250).replace(/\n/g, ' ')}" — u/${c.author} on r/${c.subreddit}`;
  copyToClipboard(text);
}

function batchExportSocial(count) {
  if (!socialData.length) { toast('No data to export. Run a search first.'); return; }
  const items = socialData.slice(0, count);
  const content = items.map((c, i) =>
    `--- ${i + 1}. Score: ${c.score} | u/${c.author} on r/${c.subreddit} | ${formatDate(c.created_utc)} ---\n\n"${(c.body || '').trim()}"\n\nPermalink: ${commentPermalink(c)}\n`
  ).join('\n');
  downloadFile(content, `viral_takes_top${count}.txt`, 'text/plain');
  toast(`Exported top ${Math.min(count, items.length)} takes!`);
}

// =============================================================================
// TAB 6: SUBREDDIT GROWTH & TEAM POPULARITY
// Uses time_series for comment counts (NOT comments/search/aggregate which 422s)
// =============================================================================
let growthResults = null;
const growthSortState = {};

async function loadGrowthData() {
  const resultsEl = document.getElementById('growthResults');
  const progressEl = document.getElementById('growthProgress');
  const fillEl = document.getElementById('growthProgressFill');
  progressEl.style.display = 'block';
  showLoading(resultsEl);

  const cachedGrowth = Cache.get('growth_all_teams');
  if (cachedGrowth) {
    growthResults = cachedGrowth;
    progressEl.style.display = 'none';
    renderGrowthData();
    toast('Loaded from cache!');
    return;
  }

  const teams = Object.entries(NBA_TEAMS);
  const results = [];
  let completed = 0;

  try {
    for (const [team, sub] of teams) {
      try {
        // Use posts aggregate + time_series for comments (avoids 422)
        const [recent, previous, recentCommentsTs] = await Promise.all([
          api('/posts/search/aggregate', { subreddit: sub, aggregate: 'created_utc', frequency: 'month', after: daysAgo(90) }),
          api('/posts/search/aggregate', { subreddit: sub, aggregate: 'created_utc', frequency: 'month', after: daysAgo(180), before: daysAgo(90) }),
          api('/time_series', { key: `r/${sub}/comments/count`, precision: 'month', after: daysAgo(90) })
        ]);

        const recentPosts = (recent.data || []).reduce((s, d) => s + parseInt(d.count || 0), 0);
        const prevPosts = (previous.data || []).reduce((s, d) => s + parseInt(d.count || 0), 0);
        const recentCommentCount = (recentCommentsTs.data || []).reduce((s, d) => s + (d.value || 0), 0);
        const growth = prevPosts > 0 ? Math.round(((recentPosts - prevPosts) / prevPosts) * 100) : 0;

        results.push({ team, sub, recentPosts, recentComments: recentCommentCount, totalActivity: recentPosts + recentCommentCount, growth, avgPostScore: 0 });
      } catch (e) {
        console.warn(`Growth data failed for ${team}:`, e.message);
        results.push({ team, sub, recentPosts: 0, recentComments: 0, totalActivity: 0, growth: 0, avgPostScore: 0 });
      }
      completed++;
      fillEl.style.width = `${(completed / teams.length) * 100}%`;
      resultsEl.innerHTML = `<div class="loading-overlay"><div class="spinner"></div> Loading ${completed}/${teams.length} teams...</div>`;
    }

    growthResults = results;
    Cache.set('growth_all_teams', results);
    progressEl.style.display = 'none';
    renderGrowthData();
  } catch (err) {
    progressEl.style.display = 'none';
    showError(resultsEl, 'Error loading growth data: ' + err.message);
  }
}

const GROWTH_COLUMNS = [
  { field: 'team', label: 'Team' },
  { field: 'sub', label: 'Subreddit', render: t => `<a href="https://reddit.com/r/${t.sub}" target="_blank">r/${t.sub}</a>` },
  { field: 'totalActivity', label: 'Activity (90d)', render: t => t.totalActivity.toLocaleString() },
  { field: 'growth', label: 'Growth %', defaultSort: true, render: t => {
    const cls = t.growth > 0 ? 'badge-green' : t.growth < 0 ? 'badge-red' : 'badge-orange';
    return `<span class="badge ${cls}">${t.growth > 0 ? '+' : ''}${t.growth}%</span>`;
  }},
  { field: 'recentPosts', label: 'Posts', render: t => t.recentPosts.toLocaleString() },
  { field: 'recentComments', label: 'Comments', render: t => t.recentComments.toLocaleString() }
];

function renderGrowthData() {
  if (!growthResults) return;
  const sorted = [...growthResults].sort((a, b) => b.growth - a.growth);

  // Chart
  document.getElementById('growthChart').style.display = 'block';
  const top15 = sorted.slice(0, 15);
  getOrCreateChart('growthChartCanvas', {
    type: 'bar',
    data: {
      labels: top15.map(t => t.team.replace(/.*\s/, '')),
      datasets: [{
        label: 'Growth %',
        data: top15.map(t => t.growth),
        backgroundColor: top15.map(t => t.growth > 0 ? '#16a34a' : '#f97316')
      }]
    },
    options: {
      responsive: true, indexAxis: 'y',
      plugins: { title: { display: true, text: 'Fastest Growing NBA Fanbases on Reddit (90-day)', color: '#1a1a2e' } },
      scales: { x: { beginAtZero: true } }
    }
  });

  growthSortState._sort = null;
  renderSortableTable('growthResults', growthResults, GROWTH_COLUMNS, growthSortState);
}

// =============================================================================
// TAB 7: HISTORICAL REACTIONS
// =============================================================================
let historyData = [];

async function searchHistory() {
  const query = document.getElementById('historyQuery').value.trim();
  if (!query) { toast('Please enter a search query.'); return; }
  const after = document.getElementById('historyAfter').value;
  const before = document.getElementById('historyBefore').value;
  const resultsEl = document.getElementById('historyResults');
  document.getElementById('historyBrief').style.display = 'none';
  showLoading(resultsEl);

  try {
    const res = await api('/posts/search', {
      subreddit: 'nba', query, after, before, limit: 100
    });
    historyData = (res.data || []).sort((a, b) => ((b.score||0) + (b.num_comments||0)) - ((a.score||0) + (a.num_comments||0)));

    if (!historyData.length) { showEmpty(resultsEl, 'No posts found for that query and date range.'); return; }

    resultsEl.innerHTML = historyData.slice(0, 50).map(p => {
      const thumb = renderThumbnail(p);
      return `<div class="card" style="display:flex;gap:12px;align-items:flex-start">
        ${thumb ? `<div>${thumb}</div>` : ''}
        <div style="flex:1;min-width:0">
          <div class="card-title"><a href="${postPermalink(p)}" target="_blank">${escapeHtml(p.title)}</a></div>
          <div class="comment-meta">
            <span>u/${escapeHtml(p.author)}</span>
            <span>Score: ${(p.score||0).toLocaleString()}</span>
            <span>${(p.num_comments||0).toLocaleString()} comments</span>
            <span>${formatDate(p.created_utc)}</span>
            <span class="badge badge-orange">r/${escapeHtml(p.subreddit)}</span>
          </div>
          ${p.selftext ? `<div class="comment-scroll" style="margin-top:8px;color:var(--text-secondary);font-size:0.85rem">${escapeHtml(p.selftext)}</div>` : ''}
          <button class="btn btn-sm btn-secondary" style="margin-top:8px" onclick="expandThread('${(p.id||'').replace('t3_','')}', this)">Expand Thread</button>
          <div id="thread-${(p.id||'').replace('t3_','')}" class="expand-content"></div>
        </div>
      </div>`;
    }).join('');
  } catch (err) {
    showError(resultsEl, 'Error searching history: ' + err.message);
  }
}

function parseTreeComments(data) {
  if (!data || !data.length) return [];
  return data.filter(item => item.kind === 't1' && item.data).map(item => item.data);
}

async function expandThread(postId, btn) {
  const threadEl = document.getElementById('thread-' + postId);
  if (threadEl.classList.contains('open')) {
    threadEl.classList.remove('open');
    btn.textContent = 'Expand Thread';
    return;
  }
  btn.textContent = 'Loading...';
  btn.disabled = true;
  try {
    const res = await api('/comments/tree', { link_id: 't3_' + postId, limit: 20 });
    const comments = parseTreeComments(res.data);
    if (!comments.length) {
      threadEl.innerHTML = '<div class="empty-state">No comments found.</div>';
    } else {
      threadEl.innerHTML = comments.slice(0, 15).map(c => `
        <div class="comment-card">
          <div class="comment-body comment-scroll">${escapeHtml(c.body || '')}</div>
          <div class="comment-meta">
            <span>u/${escapeHtml(c.author || '[deleted]')}</span>
            <span>Score: ${c.score || 0}</span>
            <span>${formatDate(c.created_utc)}</span>
          </div>
        </div>`).join('');
    }
    threadEl.classList.add('open');
    btn.textContent = 'Collapse Thread';
  } catch (err) {
    threadEl.innerHTML = `<div class="error-msg">Could not load comments: ${escapeHtml(err.message)}</div>`;
    threadEl.classList.add('open');
    btn.textContent = 'Retry';
  }
  btn.disabled = false;
}

async function generateBrief() {
  if (!historyData.length) { toast('Search for posts first.'); return; }
  const briefEl = document.getElementById('historyBrief');
  briefEl.style.display = 'block';
  briefEl.innerHTML = '<div class="loading-overlay"><div class="spinner"></div> Generating article brief...</div>';

  const topPosts = historyData.slice(0, 5);
  let brief = `# Reddit Reaction Brief: "${document.getElementById('historyQuery').value}"\n`;
  brief += `Generated: ${new Date().toLocaleDateString()}\n\n`;

  for (let i = 0; i < topPosts.length; i++) {
    const p = topPosts[i];
    brief += `## ${i + 1}. ${p.title}\n`;
    brief += `- Score: ${(p.score||0).toLocaleString()} | Comments: ${(p.num_comments||0).toLocaleString()} | Date: ${formatDate(p.created_utc)}\n`;
    brief += `- Link: ${postPermalink(p)}\n\n`;

    try {
      const res = await api('/comments/tree', { link_id: (p.id || '').startsWith('t3_') ? p.id : 't3_' + p.id, limit: 5 });
      const comments = parseTreeComments(res.data).slice(0, 3);
      comments.forEach((c, j) => {
        brief += `> **Top Comment ${j + 1}** (Score: ${c.score || 0}, u/${c.author || 'deleted'}):\n`;
        brief += `> ${(c.body || '').trim()}\n\n`;
      });
    } catch {
      brief += `> *Could not load comments for this post.*\n\n`;
    }
    brief += `---\n\n`;
  }

  briefEl.innerHTML = `
    <div class="card">
      <div class="card-title">Article Brief <button class="btn btn-sm" onclick="copyToClipboard(document.getElementById('briefContent').textContent)">Copy</button></div>
      <div class="markdown-brief" id="briefContent">${escapeHtml(brief)}</div>
    </div>`;
}

// =============================================================================
// INITIALIZATION
// =============================================================================
function init() {
  const today = new Date().toISOString().split('T')[0];
  const oneDayAgo = daysAgo(1);

  document.getElementById('rumorAfter').value = oneDayAgo;
  document.getElementById('rumorBefore').value = today;
  document.getElementById('socialAfter').value = oneDayAgo;
  document.getElementById('socialBefore').value = today;
  document.getElementById('sentimentAfter').value = oneDayAgo;
  document.getElementById('sentimentBefore').value = today;
  document.getElementById('historyAfter').value = oneDayAgo;
  document.getElementById('historyBefore').value = today;

  const teamOptions = Object.entries(NBA_TEAMS).map(([team, sub]) =>
    `<option value="${sub}">${team}</option>`).join('');
  document.getElementById('sentimentTeam').innerHTML = teamOptions;
  document.getElementById('sentimentTeam2').innerHTML = '<option value="">-- None (Single Team) --</option>' + teamOptions;
  document.getElementById('perceptionTeams').innerHTML = Object.entries(NBA_TEAMS).map(([team, sub]) =>
    `<label class="team-checkbox"><input type="checkbox" value="${sub}"> ${team}</label>`).join('');

  checkApiStatus();

  // Auto-load Trend Detection with Last 24 Hours on startup
  setTimeout(() => loadTrends(), 300);

  document.addEventListener('keydown', e => {
    if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
      const panel = e.target.closest('.tab-panel');
      if (!panel) return;
      const btn = panel.querySelector('.btn');
      if (btn) btn.click();
    }
  });
}

async function checkApiStatus() {
  try {
    await fetch(API_BASE + '/posts/search?limit=1');
    document.getElementById('apiDot').className = 'api-dot online';
    document.getElementById('apiStatusText').textContent = 'API Online';
  } catch {
    document.getElementById('apiDot').className = 'api-dot offline';
    document.getElementById('apiStatusText').textContent = 'API Offline';
  }
}

document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
